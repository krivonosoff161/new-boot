# v2.0 (обновлен для корректной работы с ботами v2.0)
"""
Анализ статистики торговых ботов.
v2.0: Обновлен для корректной работы с ботами v2.0.
"""
import ccxt.async_support as ccxt
import numpy as np
import talib
import asyncio
import time
import logging
import sys
import os
import json
import math
from datetime import datetime, timedelta
from dotenv import load_dotenv
# Импорт модулей проекта
from config_manager import ConfigManager
# Импорт базового класса и TradeEvent для согласованности логов
from base_trading_bot import BaseTradingBot, TradeEvent

# Загрузка переменных окружения
load_dotenv()
os.makedirs('logs', exist_ok=True)
os.makedirs('reports', exist_ok=True)

# === v2.0: Исправления и дополнения ===
# - Использование ConfigManager для загрузки конфигурации
# - Использование логгера из BaseTradingBot для согласованности
# - Улучшенная обработка ошибок и путей к файлам
# === /v2.0 ===

# Инициализация логгера, аналогично другим ботам
logger_instance = BaseTradingBot('analyzer') # Создаем временный экземпляр только для логгера
logger = logger_instance.logger

# Инициализация конфигурации
config_manager = ConfigManager()
CONFIG = config_manager.get_config()
SYMBOLS = CONFIG['symbols']

def analyze_log_file(bot_type):
    """
    Анализирует лог-файл бота.
    v2.0: Использование путей и структуры логов из v2.0.
    """
    log_file_path = f'logs/{bot_type}_bot.log'
    if not os.path.exists(log_file_path):
        logger.warning(f"Лог-файл {log_file_path} не найден.")
        return {
            "total_lines": 0,
            "errors": 0,
            "warnings": 0,
            "trades": 0,
            "start_time": None,
            "end_time": None
        }

    stats = {
        "total_lines": 0,
        "errors": 0,
        "warnings": 0,
        "trades": 0,
        "start_time": None,
        "end_time": None
    }

    try:
        with open(log_file_path, 'r', encoding='utf-8') as f:
            first_line = True
            for line in f:
                stats["total_lines"] += 1
                if "ERROR" in line:
                    stats["errors"] += 1
                if "WARNING" in line:
                    stats["warnings"] += 1
                if "ОТКРЫТИЕ" in line or "ЗАКРЫТИЕ" in line:
                    stats["trades"] += 1
                
                # Попытка извлечь время из первой и последней строк
                try:
                    # Формат времени в логах: 2024-05-21 10:00:00,123
                    timestamp_str = line.split(' - ')[0]
                    log_time = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                    if first_line:
                        stats["start_time"] = log_time
                        first_line = False
                    stats["end_time"] = log_time
                except ValueError:
                    # Если не удалось распарсить время, продолжаем
                    pass
                    
    except Exception as e:
        logger.error(f"Ошибка анализа лог-файла {log_file_path}: {e}")
        return stats
        
    return stats

def generate_report(bot_type, log_stats):
    """
    Генерирует текстовый отчет.
    v2.0: Улучшенный формат отчета.
    """
    report_lines = []
    report_lines.append("=" * 50)
    report_lines.append(f"Отчет анализа для {bot_type.upper()} бота")
    report_lines.append(f"Сгенерирован: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report_lines.append("=" * 50)
    report_lines.append("")

    if log_stats:
        duration = "N/A"
        if log_stats['start_time'] and log_stats['end_time']:
            duration_td = log_stats['end_time'] - log_stats['start_time']
            duration_hours = duration_td.total_seconds() / 3600
            duration = f"{duration_hours:.2f} часов"
            
        report_lines.append("--- Статистика логов ---")
        report_lines.append(f"  Всего строк: {log_stats['total_lines']}")
        report_lines.append(f"  Ошибок: {log_stats['errors']}")
        report_lines.append(f"  Предупреждений: {log_stats['warnings']}")
        report_lines.append(f"  Сделок: {log_stats['trades']}")
        report_lines.append(f"  Начало логов: {log_stats['start_time'].strftime('%Y-%m-%d %H:%M:%S') if log_stats['start_time'] else 'N/A'}")
        report_lines.append(f"  Конец логов: {log_stats['end_time'].strftime('%Y-%m-%d %H:%M:%S') if log_stats['end_time'] else 'N/A'}")
        report_lines.append(f"  Длительность: {duration}")
    else:
        report_lines.append("Статистика логов недоступна.")

    report_lines.append("")
    report_lines.append("=" * 50)
    report_lines.append("Конец отчета")
    report_lines.append("=" * 50)
    
    return "\n".join(report_lines)

async def analyze_exchange_data():
    """
    Анализирует данные с биржи (балансы, позиции).
    v2.0: Использование параметров из конфига, улучшенная обработка ошибок.
    """
    report_lines = []
    report_lines.append("--- Данные с биржи ---")
    
    try:
        API_KEY = os.getenv('API_KEY')
        API_SECRET = os.getenv('API_SECRET')
        PASSPHRASE = os.getenv('PASSPHRASE')
        
        if not all([API_KEY, API_SECRET, PASSPHRASE]):
             report_lines.append("❌ API ключи не найдены в .env")
             return "\n".join(report_lines)

        exchange = ccxt.okx({
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'password': PASSPHRASE,
            'sandbox': True, # Используем демо-режим, как в ботах
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        
        await exchange.load_markets()
        
        # Получение баланса
        balance = await exchange.fetch_balance({'type': 'spot'})
        report_lines.append("Балансы:")
        total_equity = 0.0
        for symbol in SYMBOLS:
            try:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_balance = balance['total'].get(base_currency, 0)
                quote_balance = balance['total'].get(quote_currency, 0)
                
                if base_balance > 1e-8 or quote_balance > 1e-8:
                    # Получаем цену для расчета эквити
                    ticker = await exchange.fetch_ticker(symbol)
                    price = ticker['last']
                    equity = base_balance * price + quote_balance
                    total_equity += equity
                    report_lines.append(f"  {symbol}: {base_balance:.6f} {base_currency} + {quote_balance:.2f} {quote_currency} ≈ ${equity:.2f}")
            except Exception as e:
                report_lines.append(f"  {symbol}: Ошибка получения данных - {e}")
        
        report_lines.append(f"Общее эквити (примерное): ${total_equity:.2f} USDT")
        
        # Получение открытых ордеров
        report_lines.append("\nОткрытые ордера:")
        total_orders = 0
        for symbol in SYMBOLS:
            try:
                orders = await exchange.fetch_open_orders(symbol)
                if orders:
                    report_lines.append(f"  {symbol}:")
                    for order in orders:
                        total_orders += 1
                        side = order['side']
                        price = order['price']
                        amount = order['amount']
                        report_lines.append(f"    - {side.upper()} {amount:.6f} @ {price:.2f}")
            except Exception as e:
                report_lines.append(f"  {symbol}: Ошибка получения ордеров - {e}")
        
        if total_orders == 0:
            report_lines.append("  Нет открытых ордеров.")
            
    except Exception as e:
        logger.error(f"Ошибка анализа данных с биржи: {e}")
        report_lines.append(f"❌ Ошибка анализа данных с биржи: {e}")
        
    return "\n".join(report_lines)

async def main():
    """Основная функция анализа"""
    if len(sys.argv) < 2:
        print("Использование: python multi_analyze_stats.py <bot_type>")
        print("  bot_type: 'grid', 'scalp' или 'all'")
        sys.exit(1)

    bot_type = sys.argv[1]
    
    if not os.path.exists('.env'):
        print("❌ Файл .env не найден!")
        print("Создайте файл .env с вашими API ключами")
        sys.exit(1)

    logger.info(f"Запуск анализа для '{bot_type}'...")
    
    full_report = []
    full_report.append(f"МАСШТАБНЫЙ АНАЛИЗ ТОРГОВОГО БОТА - {bot_type.upper()}")
    full_report.append(f"Время запуска: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    full_report.append("-" * 60)
    full_report.append("")

    try:
        if bot_type in ['grid', 'scalp']:
            log_stats = analyze_log_file(bot_type)
            report = generate_report(bot_type, log_stats)
            full_report.append(report)
            full_report.append("")
            
        elif bot_type == 'all':
            # Анализ Grid
            log_stats_grid = analyze_log_file('grid')
            report_grid = generate_report('grid', log_stats_grid)
            full_report.append(report_grid)
            full_report.append("")
            
            # Анализ Scalp
            log_stats_scalp = analyze_log_file('scalp')
            report_scalp = generate_report('scalp', log_stats_scalp)
            full_report.append(report_scalp)
            full_report.append("")
        else:
            logger.error(f"Неверный тип бота: {bot_type}")
            full_report.append(f"❌ Неверный тип бота: {bot_type}")
            full_report.append("Допустимые значения: 'grid', 'scalp', 'all'")
            full_report.append("")
            
        # Анализ данных с биржи
        exchange_report = await analyze_exchange_data()
        full_report.append(exchange_report)
        full_report.append("")
        
    except Exception as e:
        logger.error(f"Критическая ошибка во время анализа: {e}")
        full_report.append(f"❌ Критическая ошибка во время анализа: {e}")
        
    # Сохранение отчета в файл
    timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
    report_filename = f"reports/analysis_report_{bot_type}_{timestamp_str}.txt"
    
    try:
        with open(report_filename, 'w', encoding='utf-8') as f:
            f.write("\n".join(full_report))
        logger.info(f"✅ Анализ завершен. Отчет сохранен в '{report_filename}'")
        print(f"✅ Анализ завершен. Отчет сохранен в '{report_filename}'")
    except Exception as e:
        logger.error(f"Ошибка сохранения отчета в файл: {e}")
        print(f"⚠️ Анализ завершен, но отчет не удалось сохранить в файл: {e}")
        print("\n--- НАЧАЛО ОТЧЕТА ---")
        print("\n".join(full_report))
        print("--- КОНЕЦ ОТЧЕТА ---")

if __name__ == "__main__":
    asyncio.run(main())



# v2.0 (обновлен для корректной работы с ботами)
"""
Модуль IPC (Inter-Process Communication) для взаимодействия с ботами.
v2.0: Обновлен для корректной работы с ботами, добавлены методы остановки.
"""
import asyncio
import logging
from aiohttp import web, ClientSession
import json
import time

logger = logging.getLogger(__name__)

# === КЛИЕНТ ===

class BotIPCClient:
    """
    Клиент IPC для взаимодействия с ботами.
    v2.0: Обновлен для корректной работы с ботами.
    """
    def __init__(self, base_url):
        self.base_url = base_url.rstrip('/')
        self.session = None

    async def start(self):
        """Запуск клиента (создание сессии)"""
        # Используем timeout для всех запросов
        timeout = aiohttp.ClientTimeout(total=10) 
        self.session = ClientSession(timeout=timeout)
        logger.debug(f"IPC клиент запущен для {self.base_url}")

    async def close(self):
        """Закрытие клиента"""
        if self.session:
            await self.session.close()
            logger.debug(f"IPC клиент закрыт для {self.base_url}")

    async def get_status(self):
        """Получение статуса бота"""
        if not self.session:
            return {"error": "Клиент не запущен"}
        try:
            async with self.session.get(f"{self.base_url}/status") as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return data
                else:
                    return {"error": f"HTTP {resp.status}"}
        except asyncio.TimeoutError:
            return {"error": "Таймаут запроса"}
        except Exception as e:
            logger.error(f"IPC ошибка get_status: {e}")
            return {"error": str(e)}

    # v2.0: Добавлен метод для отправки команды остановки
    async def send_stop_command(self):
        """Отправка команды остановки бота"""
        if not self.session:
            return {"error": "Клиент не запущен"}
        try:
            async with self.session.post(f"{self.base_url}/stop") as resp:
                if resp.status == 200:
                    data = await resp.json()
                    logger.info(f"Команда остановки отправлена на {self.base_url}")
                    return data
                else:
                    error_msg = f"HTTP {resp.status}"
                    logger.error(f"Ошибка отправки команды остановки на {self.base_url}: {error_msg}")
                    return {"error": error_msg}
        except asyncio.TimeoutError:
            error_msg = "Таймаут запроса остановки"
            logger.error(f"Таймаут при отправке команды остановки на {self.base_url}")
            return {"error": error_msg}
        except Exception as e:
            logger.error(f"IPC ошибка send_stop_command: {e}")
            return {"error": str(e)}


# === СЕРВЕР ДЛЯ GRID БОТА ===

class GridBotIPCServer:
    """
    Сервер IPC для Grid-бота.
    v2.0: Обновлен для корректной работы с Grid-ботом, добавлена команда остановки.
    """
    def __init__(self, bot_instance, port=8081):
        self.bot = bot_instance
        self.port = port
        self.runner = None
        self.site = None

    async def status_handler(self, request):
        """Обработчик запроса статуса"""
        try:
            # Получаем актуальный капитал
            await self.bot.update_capital()
            
            # Собираем информацию о позициях/ордерах
            positions_info = []
            for symbol, orders_dict in self.bot.asset_grids.items():
                for order_id, order_info in orders_dict.items():
                    positions_info.append({
                        'symbol': symbol,
                        'order_id': order_id,
                        'type': order_info['type'],
                        'price': order_info['price'],
                        'amount': order_info['amount'],
                        'level': order_info['level']
                    })
            
            data = {
                'status': 'running',
                'timestamp': time.time(),
                'equity': self.bot.total_capital,
                'working_capital': self.bot.working_capital,
                'reserve_capital': self.bot.reserve_capital,
                'positions': positions_info,
                'allocated_capital': self.bot.allocated_capital
            }
            return web.json_response(data)
        except Exception as e:
            logger.error(f"IPC ошибка status_handler: {e}")
            return web.json_response({'error': str(e)}, status=500)

    # v2.0: Добавлен обработчик команды остановки
    async def stop_handler(self, request):
        """Обработчик команды остановки"""
        try:
            logger.info("Получена команда остановки через IPC для Grid-бота")
            # Вызываем метод закрытия позиций бота
            await self.bot.close_all_positions()
            # Устанавливаем флаг остановки
            self.bot.running = False
            return web.json_response({'message': 'Grid-бот останавливается, позиции закрываются'})
        except Exception as e:
            logger.error(f"IPC ошибка stop_handler: {e}")
            return web.json_response({'error': str(e)}, status=500)

    async def start(self):
        """Запуск сервера"""
        try:
            app = web.Application()
            app.add_routes([
                web.get('/status', self.status_handler),
                # v2.0: Добавлен маршрут для остановки
                web.post('/stop', self.stop_handler),
            ])
            self.runner = web.AppRunner(app)
            await self.runner.setup()
            self.site = web.TCPSite(self.runner, 'localhost', self.port)
            await self.site.start()
            logger.info(f"Grid IPC сервер запущен на http://localhost:{self.port}")
        except Exception as e:
            logger.error(f"Ошибка запуска Grid IPC сервера: {e}")

    async def stop(self):
        """Остановка сервера"""
        if self.site:
            await self.site.stop()
        if self.runner:
            await self.runner.cleanup()
        logger.info("Grid IPC сервер остановлен")


# === СЕРВЕР ДЛЯ SCALP БОТА ===

class ScalpBotIPCServer:
    """
    Сервер IPC для Scalp-бота.
    v2.0: Обновлен для корректной работы с Scalp-ботом, добавлена команда остановки.
    """
    def __init__(self, bot_instance, port=8082):
        self.bot = bot_instance
        self.port = port
        self.runner = None
        self.site = None

    async def status_handler(self, request):
        """Обработчик запроса статуса"""
        try:
            # Получаем актуальный капитал
            await self.bot.update_capital()
            
            # Собираем информацию о позициях
            positions_info = []
            for symbol, pos_info in self.bot.positions.items():
                positions_info.append({
                    'symbol': symbol,
                    'side': pos_info['side'],
                    'amount': pos_info['amount'],
                    'entry_price': pos_info['entry'],
                    'open_time': pos_info['timestamp']
                })
            
            data = {
                'status': 'running',
                'timestamp': time.time(),
                'equity': self.bot.total_capital,
                'working_capital': self.bot.working_capital,
                'reserve_capital': self.bot.reserve_capital,
                'positions': positions_info,
                'allocated_capital': self.bot.allocated_capital
            }
            return web.json_response(data)
        except Exception as e:
            logger.error(f"IPC ошибка status_handler: {e}")
            return web.json_response({'error': str(e)}, status=500)

    # v2.0: Добавлен обработчик команды остановки
    async def stop_handler(self, request):
        """Обработчик команды остановки"""
        try:
            logger.info("Получена команда остановки через IPC для Scalp-бота")
            # Вызываем метод закрытия позиций бота
            await self.bot.close_all_positions()
            # Устанавливаем флаг остановки
            self.bot.running = False
            return web.json_response({'message': 'Scalp-бот останавливается, позиции закрываются'})
        except Exception as e:
            logger.error(f"IPC ошибка stop_handler: {e}")
            return web.json_response({'error': str(e)}, status=500)

    async def start(self):
        """Запуск сервера"""
        try:
            app = web.Application()
            app.add_routes([
                web.get('/status', self.status_handler),
                # v2.0: Добавлен маршрут для остановки
                web.post('/stop', self.stop_handler),
            ])
            self.runner = web.AppRunner(app)
            await self.runner.setup()
            self.site = web.TCPSite(self.runner, 'localhost', self.port)
            await self.site.start()
            logger.info(f"Scalp IPC сервер запущен на http://localhost:{self.port}")
        except Exception as e:
            logger.error(f"Ошибка запуска Scalp IPC сервера: {e}")

    async def stop(self):
        """Остановка сервера"""
        if self.site:
            await self.site.stop()
        if self.runner:
            await self.runner.cleanup()
        logger.info("Scalp IPC сервер остановлен")



# v2.0 (обновлен для корректной работы с Telegram)
"""
Модуль безопасности для управления пользователями.
v2.0: Обновлен для корректной работы с Telegram.
"""
import json
import logging
import os
from telegram import Bot

logger = logging.getLogger(__name__)
USERS_FILE = 'users.json'

class SecurityManager:
    """
    Модуль безопасности для управления пользователями.
    v2.0: Обновлен для корректной работы с Telegram.
    """
    def __init__(self, users_file=USERS_FILE, telegram_token=None):
        self.users_file = users_file
        self.telegram_token = telegram_token
        self.users = self.load_users()

    def load_users(self):
        """Загрузка списка пользователей"""
        if os.path.exists(self.users_file):
            try:
                with open(self.users_file, 'r') as f:
                    data = json.load(f)
                    # Убедимся, что это список
                    if isinstance(data, list):
                        logger.info(f"✅ Список пользователей загружен из {self.users_file}")
                        return data
                    else:
                        logger.warning(f"⚠️ Неверный формат файла {self.users_file}. Создаю новый список.")
            except Exception as e:
                logger.error(f"❌ Ошибка загрузки {self.users_file}: {e}")
        # Если файл не существует или ошибка, создаем дефолтный список
        # Первые два ID - администраторы по умолчанию
        default_users = [462885677, 5954433829] # Замените на реальные ID админов
        self.save_users(default_users)
        logger.info(f"🆕 Создан дефолтный список пользователей в {self.users_file}")
        return default_users

    def save_users(self, users_list=None):
        """Сохранение списка пользователей"""
        if users_list is not None:
            self.users = users_list
        try:
            with open(self.users_file, 'w') as f:
                json.dump(self.users, f, indent=2)
            logger.info(f"✅ Список пользователей сохранен в {self.users_file}")
        except Exception as e:
            logger.error(f"❌ Ошибка сохранения {self.users_file}: {e}")

    def is_authorized(self, user_id):
        """Проверка, авторизован ли пользователь"""
        return int(user_id) in self.users

    def is_admin(self, user_id):
        """Проверка, является ли пользователь администратором"""
        # Первые два пользователя в списке - администраторы
        return int(user_id) in self.users[:2] if len(self.users) >= 2 else int(user_id) == self.users[0] if self.users else False

    def add_user(self, user_id):
        """Добавление пользователя"""
        user_id = int(user_id)
        if user_id not in self.users:
            self.users.append(user_id)
            self.save_users()
            logger.info(f"✅ Пользователь {user_id} добавлен")
            return True
        else:
            logger.info(f"ℹ️ Пользователь {user_id} уже существует")
            return False

    def remove_user(self, user_id):
        """Удаление пользователя"""
        user_id = int(user_id)
        if user_id in self.users:
            # Не позволяем удалить администраторов
            if self.is_admin(user_id):
                logger.warning(f"⚠️ Нельзя удалить администратора {user_id}")
                return False
            self.users.remove(user_id)
            self.save_users()
            logger.info(f"✅ Пользователь {user_id} удален")
            return True
        else:
            logger.info(f"ℹ️ Пользователь {user_id} не найден")
            return False

    def get_users(self):
        """Получение списка всех пользователей"""
        return self.users.copy()

    async def notify_admins(self, tg_bot: Bot, user_id, username, first_name, last_name):
        """Уведомление администраторов о новом пользователе"""
        try:
            message = (f"🔒 Запрос доступа\n"
                       f"ID: <code>{user_id}</code>\n"
                       f"Username: @{username}\n"
                       f"Имя: {first_name}\n"
                       f"Фамилия: {last_name}\n\n"
                       f"Для добавления пользователя используйте команду:\n"
                       f"<code>/add_user {user_id}</code>")
            
            for admin_id in self.users[:2]: # Уведомляем только первых двух админов
                try:
                    await tg_bot.send_message(chat_id=admin_id, text=message, parse_mode='HTML')
                except Exception as e:
                    logger.error(f"❌ Ошибка уведомления администратора {admin_id}: {e}")
            logger.info(f"ℹ️ Запрос доступа от пользователя {user_id} отправлен администраторам")
        except Exception as e:
            logger.error(f"❌ Ошибка уведомления администраторов: {e}")


# v2.0 (+правки из анализа: добавлены новые параметры конфигурации)
"""
Менеджер конфигурации.
v2.0: Добавлены новые параметры конфигурации из чек-листа.
"""
import json
import os
import logging

logger = logging.getLogger(__name__)

CONFIG_FILE = 'bot_config.json'

class ConfigManager:
    """
    Менеджер конфигурации.
    v2.0: Добавлены новые параметры конфигурации из чек-листа.
    """
    def __init__(self):
        self.config = self.load_config()

    def load_config(self):
        """Загрузка конфигурации"""
        # Дефолтная конфигурация с новыми параметрами
        default_config = {
            "symbols": ["BTC/USDT", "ETH/USDT", "BNB/USDT", "SOL/USDT", "XRP/USDT", "ADA/USDT", "DOT/USDT"],
            "chat_ids": [462885677, 5954433829],
            "redistribution_interval": 1800, # 30 минут
            # v2.0: Добавлен параметр min_alloc_usd
            "min_alloc_usd": 100,
            # v2.0: Добавлен параметр balance_cache_sec
            "balance_cache_sec": 60,
            "capital_split": { # Добавлено для разделения капитала
                "grid": 0.6,
                "scalp": 0.4
            },
            "grid": {
                "min_order_usd": 20,
                "max_position_size": 200,
                "exposure_limit": 0.5,
                "base_spacing": 0.008,
                "max_levels": 6,
                "sleep_interval": 15,
                # v2.0: Добавлен параметр cci_block
                "cci_block": -150,
                # v2.0: Добавлен параметр grid_mode
                "grid_mode": "futures",
                "order_timeout_seconds": 600 # Таймаут ордера по умолчанию
            },
            "scalp": {
                "min_order_usd": 15,
                "max_positions": 8,
                "position_size_percent": 0.05,
                "sleep_interval": 5, # Исправлено с 2 на 5
                "signal_threshold": 50,
                "max_hold_seconds": 180,
                "tp_pct": 0.15,
                "sl_pct": 0.25,
                "fee_rate": 0.0004, # Пример комиссии
                "indicators": {
                    "rsi": {
                        "timeperiod": 3
                    },
                    "stoch": {
                        "fastk_period": 3,
                        "slowk_period": 2,
                        "slowk_matype": 0,
                        "slowd_period": 2,
                        "slowd_matype": 0
                    },
                    "macd": {
                        "fastperiod": 3,
                        "slowperiod": 7,
                        "signalperiod": 2
                    },
                    "ema": {
                        "short_period": 3,
                        "long_period": 7
                    },
                    "atr": {
                        "timeperiod": 3
                    },
                    "bb": {
                        "timeperiod": 20,
                        "nbdevup": 2,
                        "nbdevdn": 2
                    }
                }
            },
            "risk": {
                "max_drawdown_pct": 0.25,
                "stop_loss_pct": 0.03
            }
        }
        
        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                # Объединяем с дефолтной конфигурацией
                for key, value in default_config.items():
                    if key not in loaded_config:
                        loaded_config[key] = value
                    elif isinstance(value, dict) and isinstance(loaded_config[key], dict):
                        # Рекурсивное объединение для вложенных словарей
                        for sub_key, sub_value in value.items():
                            if sub_key not in loaded_config[key]:
                                loaded_config[key][sub_key] = sub_value
                logger.info(f"✅ Конфигурация загружена из {CONFIG_FILE}")
                return loaded_config
            except Exception as e:
                logger.error(f"❌ Ошибка загрузки конфигурации из {CONFIG_FILE}: {e}. Используется дефолтная.")
                return default_config
        else:
            # Если файл не найден, создаем его с дефолтными значениями
            logger.warning(f"⚠️ Файл конфигурации {CONFIG_FILE} не найден. Создаю дефолтный.")
            self.save_config(default_config)
            return default_config

    def get_config(self):
        """Получение конфигурации"""
        return self.config

    def save_config(self, config_data):
        """Сохранение конфигурации в файл"""
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=2, ensure_ascii=False)
            logger.info(f"✅ Конфигурация сохранена в {CONFIG_FILE}")
        except Exception as e:
            logger.error(f"❌ Ошибка сохранения конфигурации в {CONFIG_FILE}: {e}")

    def update_config(self, new_data):
        """Обновление конфигурации"""
        self.config.update(new_data)
        self.save_config(self.config)


# v2.0 (+правки из анализа: корректная агрегация капитала, working_capital, min_alloc)
"""
Модуль для централизованного и корректного распределения капитала между стратегиями.
v2.0: Исправлена агрегация капитала (берется totalEq 1 раз), добавлены working_capital и min_alloc.
"""
import logging
import asyncio
import ccxt.async_support as ccxt
from config_manager import ConfigManager

logger = logging.getLogger(__name__)

class CapitalDistributor:
    """
    Модуль для централизованного распределения капитала между стратегиями.
    v2.0: Исправлена агрегация капитала, добавлены working_capital и min_alloc.
    """

    def __init__(self, exchange: ccxt.Exchange):
        self.ex = exchange
        self.config_manager = ConfigManager()
        self.config = self.config_manager.get_config()

    async def get_total_capital(self) -> float:
        """
        Получает общий капитал один раз из баланса USDT.
        v2.0: Исправлена ошибка дублирования баланса. Используется totalEq.
        """
        try:
            # v2.0: Получаем общий капитал один раз, как в анализе
            # Используем 'type': 'spot' как в анализе и основном коде ботов
            balance = await self.ex.fetch_balance({'type': 'spot'})
            # logger.debug(f"Raw balance response keys: {list(balance.keys())}")
            # logger.debug(f"Balance total section: {balance.get('total', {})}")

            # v2.0: Используем 'total' -> 'USDT' как в анализе
            total_usdt = float(balance.get('total', {}).get('USDT', 0.0))
            logger.info(f"💰 Общий капитал (totalEq): ${total_usdt:.2f} USDT")
            return total_usdt
        except Exception as e:
            logger.error(f"❌ Ошибка получения общего капитала: {e}")
            return 0.0

    async def distribute_for_strategy(self, strategy_type: str, symbols: list) -> dict:
        """
        Распределяет капитал для конкретной стратегии.
        v2.0: Добавлены working_capital и min_alloc.
        """
        try:
            total_capital = await self.get_total_capital()
            if total_capital <= 0:
                logger.warning("⚠️ Общий капитал равен нулю или отрицателен.")
                return {}

            # v2.0: Рабочий капитал (50% от общего, как в анализе и BaseTradingBot.run)
            working_capital = total_capital * 0.5
            strategy_share = self.config['capital_split'].get(strategy_type, 0.5)
            allocated_for_strategy = working_capital * strategy_share

            logger.info(f"💰 Рабочий капитал: ${working_capital:.2f} USDT")
            logger.info(f"📊 Доля стратегии '{strategy_type}': {strategy_share*100:.1f}% -> ${allocated_for_strategy:.2f} USDT")

            # v2.0: Минимальное выделение на пару из конфига
            min_alloc = self.config.get('min_alloc_usd', 100)

            # Базовое распределение
            base_allocation = allocated_for_strategy / len(symbols) if symbols else 0

            allocations = {}
            skipped_symbols = []

            for symbol in symbols:
                if base_allocation >= min_alloc:
                    allocations[symbol] = base_allocation
                else:
                    skipped_symbols.append(symbol)
                    logger.warning(f"⚠️ {symbol}: Пропущена из-за минимального выделения (${base_allocation:.2f} < ${min_alloc})")

            if skipped_symbols and allocations:
                # Перераспределить оставшийся капитал между оставшимися символами
                # v2.0: Уточнение логики перераспределения
                remaining_to_distribute = sum([base_allocation for _ in skipped_symbols])
                bonus_per_active = remaining_to_distribute / len(allocations) if allocations else 0

                for symbol in allocations:
                    allocations[symbol] += bonus_per_active

                logger.info(f"🔁 Перераспределено: {len(skipped_symbols)} пар пропущено, капитал перераспределен.")
            elif not allocations:
                 logger.warning(f"⚠️ Ни одна пара не прошла минимальный порог выделения для стратегии '{strategy_type}'.")

            logger.info(f"✅ Распределение для '{strategy_type}' завершено. Всего пар: {len(allocations)}, Пропущено: {len(skipped_symbols)}")
            return allocations

        except Exception as e:
            logger.error(f"❌ Ошибка распределения капитала для стратегии '{strategy_type}': {e}")
            return {}

# Пример использования:
# distributor = CapitalDistributor(exchange_instance)
# grid_allocations = await distributor.distribute_for_strategy('grid', ['BTC/USDT', 'ETH/USDT'])


# v2.0 (новый файл)
"""
Модуль для централизованной настройки логирования.
v2.0: Новый файл для улучшенного управления логами ботов.
"""
import logging
import os
from logging.handlers import RotatingFileHandler

def build_logger(bot_type: str) -> logging.Logger:
    """
    Создаёт и настраивает логгер для конкретного типа бота.
    v2.0: Новый файл для централизованной настройки логов.
    """
    # Создаем папку logs если её нет
    os.makedirs('logs', exist_ok=True)
    
    # Создаем логгер с уникальным именем для каждого типа бота
    logger = logging.getLogger(f"{bot_type}_logger")
    logger.setLevel(logging.DEBUG)
    
    # Проверяем, есть ли уже обработчики, чтобы не дублировать
    if not logger.handlers:
        # Создаем обработчик для файла с ротацией
        log_file = f'logs/{bot_type}_bot.log'
        # RotatingFileHandler с максимальным размером 10MB и 5 бэкапами
        file_handler = RotatingFileHandler(
            log_file, 
            maxBytes=10*1024*1024,  # 10 MB
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setLevel(logging.DEBUG)
        
        # Создаем обработчик для консоли
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # Создаем форматтер
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        # Добавляем обработчики к логгеру
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
    return logger


# v2.0 (+правки из анализа: закрытие позиций при остановке ботов)
"""
Telegram Bot Controller.
v2.0: Добавлено закрытие позиций при остановке ботов через IPC.
"""
import os
import sys
import json
import logging
import subprocess
import signal
import asyncio
import aiohttp
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from dotenv import load_dotenv
import ccxt.async_support as ccxt
# Импортируем security и config_manager
from security import SecurityManager
from config_manager import ConfigManager
# Новый модуль IPC (Клиентская часть)
from ipc import BotIPCClient

# Загрузка переменных окружения
load_dotenv()

# === v2.0: Исправления и дополнения из чек-листа ===
# - Добавлено закрытие позиций при остановке ботов
# === /v2.0 ===

# Настройка логгирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/controller.log", encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Глобальные переменные для процессов
global grid_process, scalp_process
grid_process = None
scalp_process = None

# Инициализация Telegram бота
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
if not TELEGRAM_TOKEN:
    raise ValueError("❌ TELEGRAM_TOKEN не найден в .env")

# Инициализация биржи для получения информации
EXCHANGE_INSTANCE = None
try:
    API_KEY = os.getenv('API_KEY')
    API_SECRET = os.getenv('API_SECRET')
    PASSPHRASE = os.getenv('PASSPHRASE')
    if API_KEY and API_SECRET and PASSPHRASE:
        EXCHANGE_INSTANCE = ccxt.okx({
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'password': PASSPHRASE,
            'sandbox': True,  # Используем демо-режим
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
    else:
        logger.warning("⚠️ API ключи не найдены в .env. Получение позиций будет ограничено.")
except Exception as e:
    EXCHANGE_INSTANCE = None
    logger.error(f"❌ Ошибка инициализации экземпляра биржи для контроллера: {e}")

# Инициализация менеджеров
security = SecurityManager('users.json', telegram_token=TELEGRAM_TOKEN)
config_manager = ConfigManager()
CONFIG = config_manager.get_config()
SYMBOLS = CONFIG['symbols']

# IPC клиенты
grid_ipc = BotIPCClient("http://localhost:8081")
scalp_ipc = BotIPCClient("http://localhost:8082")

async def init_ipc_clients(application):
    """Инициализация IPC клиентов"""
    await grid_ipc.start()
    await scalp_ipc.start()
    # application.job_queue.run_once(close_ipc_clients, when=1) # Закроем при завершении

# async def close_ipc_clients(application):
#     """Закрытие IPC клиентов"""
#     await grid_ipc.close()
#     await scalp_ipc.close()

# === v2.0: Добавлены функции для закрытия позиций через IPC ===
async def close_grid_positions_via_ipc():
    """Закрытие позиций Grid-бота через IPC"""
    try:
        # Отправляем команду на остановку (которая включает закрытие позиций)
        async with aiohttp.ClientSession() as session:
            async with session.post("http://localhost:8081/stop") as resp:
                if resp.status == 200:
                    logger.info("✅ Команда остановки (с закрытием позиций) Grid-бота отправлена через IPC")
                    return True
                else:
                    logger.error(f"❌ Ошибка отправки команды остановки Grid-бота через IPC: HTTP {resp.status}")
                    return False
    except Exception as e:
        logger.error(f"❌ Ошибка отправки команды остановки Grid-бота через IPC: {e}")
        return False

async def close_scalp_positions_via_ipc():
    """Закрытие позиций Scalp-бота через IPC"""
    try:
        # Отправляем команду на остановку (которая включает закрытие позиций)
        async with aiohttp.ClientSession() as session:
            async with session.post("http://localhost:8082/stop") as resp:
                if resp.status == 200:
                    logger.info("✅ Команда остановки (с закрытием позиций) Scalp-бота отправлена через IPC")
                    return True
                else:
                    logger.error(f"❌ Ошибка отправки команды остановки Scalp-бота через IPC: HTTP {resp.status}")
                    return False
    except Exception as e:
        logger.error(f"❌ Ошибка отправки команды остановки Scalp-бота через IPC: {e}")
        return False
# === /v2.0: Добавлены функции для закрытия позиций через IPC ===

async def monitor_bots(context: ContextTypes.DEFAULT_TYPE):
    """Мониторинг состояния ботов"""
    global grid_process, scalp_process

    status = {
        "grid_status": "не запущен",
        "scalp_status": "не запущен",
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }

    # Проверяем статус Grid процесса
    if grid_process:
        if grid_process.poll() is None:
            status["grid_status"] = "запущен"
        else:
            status["grid_status"] = f"остановлен (код: {grid_process.poll()})"

    # Проверяем статус Scalp процесса
    if scalp_process:
        if scalp_process.poll() is None:
            status["scalp_status"] = "запущен"
        else:
            status["scalp_status"] = f"остановлен (код: {scalp_process.poll()})"

    # Сохраняем статус в файл для других компонентов
    try:
        with open('bot_status.json', 'w', encoding='utf-8') as f:
            json.dump(status, f, indent=2, ensure_ascii=False)
    except Exception as e:
        logger.error(f"Ошибка сохранения статуса: {e}")

def get_bot_status(bot_type):
    """Получает статус бота из лог-файла (Заглушка, в идеале должен использовать IPC)"""
    try:
        log_file_path = f'logs/{bot_type}_bot.log'
        if os.path.exists(log_file_path):
            with open(log_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                relevant_lines = []
                for line in reversed(lines[-50:]):  # последние 50 строк
                    if any(keyword in line for keyword in ["запущен", "остановлен", "Graceful shutdown", "Error", "Exception", "TP", "SL", "позиция открыта", "позиция закрыта"]):
                        relevant_lines.append(line.strip())
                        if len(relevant_lines) >= 5:
                            break
                if relevant_lines:
                    return "\n".join(relevant_lines[:5])
        return "Нет данных"
    except Exception as e:
        logger.error(f"Ошибка получения статуса для {bot_type}: {e}")
        return f"Ошибка: {str(e)}"

def get_status():
    """Получает общий статус процессов"""
    status = {
        "grid_status": "не запущен",
        "scalp_status": "не запущен",
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    global grid_process, scalp_process

    # Проверяем статус Grid процесса
    if grid_process:
        if grid_process.poll() is None:
            status["grid_status"] = "запущен"
        else:
            status["grid_status"] = f"остановлен (код: {grid_process.poll()})"

    # Проверяем статус Scalp процесса
    if scalp_process:
        if scalp_process.poll() is None:
            status["scalp_status"] = "запущен"
        else:
            status["scalp_status"] = f"остановлен (код: {scalp_process.poll()})"

    return status

# --- Клавиатуры ---
def main_menu_keyboard(user_id):
    """Основное меню"""
    keyboard = [
        [InlineKeyboardButton("📉 Multi Grid Bot", callback_data='multi_grid_menu')],
        [InlineKeyboardButton("⚡ Multi Scalp Bot", callback_data='multi_scalp_menu')],
        [InlineKeyboardButton("⚙️ Настройки", callback_data='settings_menu')],
        [InlineKeyboardButton("📈 Анализ", callback_data='analysis_menu')],
    ]
    if security.is_admin(user_id):
        keyboard.append([InlineKeyboardButton("👥 Администрирование", callback_data='admin_menu')])
    return InlineKeyboardMarkup(keyboard)

def multi_grid_menu_keyboard(user_id):
    """Меню управления Multi Grid Bot"""
    keyboard = [
        [InlineKeyboardButton("▶️ Запустить Grid", callback_data='start_multi_grid')],
        [InlineKeyboardButton("⏹️ Остановить Grid", callback_data='stop_multi_grid')],
        [InlineKeyboardButton("📊 Статус Grid", callback_data='status_multi_grid')],
        [InlineKeyboardButton("ℹ️ Позиции Grid", callback_data='info_positions_grid')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def multi_scalp_menu_keyboard(user_id):
    """Меню управления Multi Scalp Bot"""
    keyboard = [
        [InlineKeyboardButton("▶️ Запустить Scalp", callback_data='start_multi_scalp')],
        [InlineKeyboardButton("⏹️ Остановить Scalp", callback_data='stop_multi_scalp')],
        [InlineKeyboardButton("📊 Статус Scalp", callback_data='status_multi_scalp')],
        [InlineKeyboardButton("ℹ️ Позиции Scalp", callback_data='info_positions_scalp')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard():
    """Меню настроек"""
    keyboard = [
        [InlineKeyboardButton("📉 Grid настройки", callback_data='settings_grid_menu')],
        [InlineKeyboardButton("⚡ Scalp настройки", callback_data='settings_scalp_menu')],
        [InlineKeyboardButton("🛡️ Risk настройки", callback_data='settings_risk_menu')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_grid_menu_keyboard():
    """Меню настроек Grid"""
    keyboard = [
        [InlineKeyboardButton("Мин. ордер (USD)", callback_data='edit_grid_min_order_usd')],
        [InlineKeyboardButton("Макс. позиция (USD)", callback_data='edit_grid_max_position_size')],
        [InlineKeyboardButton("Лимит экспозиции", callback_data='edit_grid_exposure_limit')],
        [InlineKeyboardButton("Базовый шаг", callback_data='edit_grid_base_spacing')],
        [InlineKeyboardButton("Макс. уровней", callback_data='edit_grid_max_levels')],
        [InlineKeyboardButton("Интервал (сек)", callback_data='edit_grid_sleep_interval')],
        [InlineKeyboardButton("Таймаут ордера (сек)", callback_data='edit_grid_order_timeout_seconds')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='settings_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_scalp_menu_keyboard():
    """Меню настроек Scalp"""
    keyboard = [
        [InlineKeyboardButton("Мин. ордер (USD)", callback_data='edit_scalp_min_order_usd')],
        [InlineKeyboardButton("Макс. позиций", callback_data='edit_scalp_max_positions')],
        [InlineKeyboardButton("Размер позиции (%)", callback_data='edit_scalp_position_size_percent')],
        [InlineKeyboardButton("Интервал (сек)", callback_data='edit_scalp_sleep_interval')],
        [InlineKeyboardButton("Порог сигнала", callback_data='edit_scalp_signal_threshold')],
        [InlineKeyboardButton("TP (%)", callback_data='edit_scalp_take_profit_pct')],
        [InlineKeyboardButton("SL (%)", callback_data='edit_scalp_stop_loss_pct')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='settings_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_risk_menu_keyboard():
    """Меню настроек Risk"""
    keyboard = [
        [InlineKeyboardButton("Макс. просадка (%)", callback_data='edit_risk_max_drawdown_pct')],
        [InlineKeyboardButton("Стоп-лосс (%)", callback_data='edit_risk_stop_loss_pct')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='settings_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def analysis_menu_keyboard():
    """Меню анализа"""
    keyboard = [
        [InlineKeyboardButton("📉 Анализ Multi Grid", callback_data='analyze_multi_grid')],
        [InlineKeyboardButton("⚡ Анализ Multi Scalp", callback_data='analyze_multi_scalp')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Меню администратора"""
    keyboard = [
        [InlineKeyboardButton("➕ Добавить пользователя", callback_data='add_user')],
        [InlineKeyboardButton("➖ Удалить пользователя", callback_data='remove_user')],
        [InlineKeyboardButton("📋 Список пользователей", callback_data='list_users')],
        [InlineKeyboardButton("⬅️ Назад", callback_data='main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

# --- Хэндлеры ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Хэндлер команды /start"""
    user_id = update.effective_user.id
    username = update.effective_user.username
    first_name = update.effective_user.first_name
    last_name = update.effective_user.last_name

    if not security.is_authorized(user_id):
        tg_bot = context.bot
        await security.notify_admins(tg_bot, user_id, username, first_name, last_name)
        await update.message.reply_text("🔒 Доступ запрещён. Администратор уведомлён.")
        return

    await update.message.reply_text(
        "🎯 Добро пожаловать в Multi Asset Trading Bot Control Panel!",
        reply_markup=main_menu_keyboard(user_id)
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Хэндлер callback'ов от кнопок"""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    data = query.data
    message = query.message

    # Проверка авторизации
    if not security.is_authorized(user_id):
        await message.edit_text("🔒 Доступ запрещён.", reply_markup=main_menu_keyboard(user_id))
        return

    # Основное меню
    if data == 'main_menu':
        await message.edit_text("🎯 Multi Asset Trading Bot Control Panel:", reply_markup=main_menu_keyboard(user_id))

    # Multi Grid Bot управление
    elif data == 'multi_grid_menu':
        await message.edit_text("📉 Multi Asset Grid Bot:", reply_markup=multi_grid_menu_keyboard(user_id))
    elif data == 'start_multi_grid' and security.is_admin(user_id):
        global grid_process
        if grid_process and grid_process.poll() is None:
            await message.reply_text("📉 Multi Grid уже запущен")
        else:
            try:
                # Запускаем как subprocess
                grid_process = subprocess.Popen([sys.executable, 'multi_asset_grid_bot.py'])
                await message.reply_text("✅ Multi Asset Grid Bot запущен")
                logger.info(f"Multi Asset Grid Bot запущен пользователем {user_id}")
            except Exception as e:
                await message.reply_text(f"❌ Ошибка запуска Multi Grid Bot: {str(e)}")
                logger.error(f"Ошибка запуска Multi Grid Bot: {e}")
    # v2.0: Обновленная функция остановки Grid-бота
    elif data == 'stop_multi_grid' and security.is_admin(user_id):
        global grid_process
        if grid_process and grid_process.poll() is None:
            try:
                # === v2.0: Добавлено закрытие позиций перед остановкой через IPC ===
                await message.reply_text("🚪 Отправляем команду остановки (с закрытием позиций) Grid-боту...")
                success = await close_grid_positions_via_ipc()
                if success:
                    await asyncio.sleep(3)  # Даем время боту обработать команду
                    await message.reply_text("✅ Команда остановки Grid-бота отправлена. Ожидаем завершения...")
                else:
                    await message.reply_text("⚠️ Не удалось отправить команду остановки Grid-боту через IPC. Продолжаем остановку процесса.")
                # === /v2.0: Добавлено закрытие позиций ===

                grid_process.terminate()
                try:
                    grid_process.wait(timeout=20) # Увеличил таймаут
                except subprocess.TimeoutExpired:
                    grid_process.kill()
                    grid_process.wait()
                grid_process = None
                await message.reply_text("✅ Multi Asset Grid Bot остановлен")
                logger.info(f"Multi Asset Grid Bot остановлен пользователем {user_id}")
            except Exception as e:
                # На случай, если процесс уже завершен или другая ошибка
                if grid_process and grid_process.poll() is None:
                    grid_process.kill()
                    grid_process.wait()
                grid_process = None
                await message.reply_text(f"⚠️ Multi Asset Grid Bot остановлен (с ошибкой): {str(e)}")
                logger.error(f"Ошибка остановки Multi Grid Bot: {e}")
        else:
            await message.reply_text("⚠️ Multi Asset Grid Bot не запущен!")
    elif data == 'status_multi_grid':
        # - ДОБАВЛЕНИЕ 3: Получение статуса через IPC -
        status = await grid_ipc.get_status()
        if "error" not in status:
            msg = f"📉 Multi Grid Bot Status:\n"
            msg += f"Status: {status.get('status', 'unknown')}\n"
            msg += f"Equity: ${status.get('equity', 0):.2f}\n"
            msg += f"Positions: {len(status.get('positions', []))}"
        else:
            msg = f"❌ Ошибка получения статуса: {status['error']}"
        await message.reply_text(msg)
        # - /ДОБАВЛЕНИЕ 3 -
    # - ДОБАВЛЕНИЕ 3: Обработчик для информации о позициях Grid -
    elif data == 'info_positions_grid':
        await message.reply_text("📊 Получение информации о позициях Grid... ")
        positions_info = await get_positions_info('grid')
        await message.reply_text(positions_info)
        # - /ДОБАВЛЕНИЕ 3 -

    # Multi Scalp Bot управление
    elif data == 'multi_scalp_menu':
        await message.edit_text("⚡ Multi Asset Scalp Bot:", reply_markup=multi_scalp_menu_keyboard(user_id))
    elif data == 'start_multi_scalp' and security.is_admin(user_id):
        global scalp_process
        if scalp_process and scalp_process.poll() is None:
            await message.reply_text("⚡ Multi Scalp уже запущен")
        else:
            try:
                # Запускаем как subprocess
                scalp_process = subprocess.Popen([sys.executable, 'multi_asset_scalp_bot.py'])
                await message.reply_text("✅ Multi Asset Scalp Bot запущен")
                logger.info(f"Multi Asset Scalp Bot запущен пользователем {user_id}")
            except Exception as e:
                await message.reply_text(f"❌ Ошибка запуска Multi Scalp Bot: {str(e)}")
                logger.error(f"Ошибка запуска Multi Scalp Bot: {e}")
    # v2.0: Обновленная функция остановки Scalp-бота
    elif data == 'stop_multi_scalp' and security.is_admin(user_id):
        global scalp_process
        if scalp_process and scalp_process.poll() is None:
            try:
                # === v2.0: Добавлено закрытие позиций перед остановкой через IPC ===
                await message.reply_text("🚪 Отправляем команду остановки (с закрытием позиций) Scalp-боту...")
                success = await close_scalp_positions_via_ipc()
                if success:
                    await asyncio.sleep(3)  # Даем время боту обработать команду
                    await message.reply_text("✅ Команда остановки Scalp-бота отправлена. Ожидаем завершения...")
                else:
                    await message.reply_text("⚠️ Не удалось отправить команду остановки Scalp-боту через IPC. Продолжаем остановку процесса.")
                # === /v2.0: Добавлено закрытие позиций ===

                scalp_process.terminate()
                try:
                    scalp_process.wait(timeout=20) # Увеличил таймаут
                except subprocess.TimeoutExpired:
                    scalp_process.kill()
                    scalp_process.wait()
                scalp_process = None
                await message.reply_text("🛑 Multi Asset Scalp Bot остановлен")
                logger.info(f"Multi Asset Scalp Bot остановлен пользователем {user_id}")
            except Exception as e:
                # На случай, если процесс уже завершен или другая ошибка
                if scalp_process and scalp_process.poll() is None:
                    scalp_process.kill()
                    scalp_process.wait()
                scalp_process = None
                await message.reply_text(f"⚠️ Multi Asset Scalp Bot остановлен (с ошибкой): {str(e)}")
                logger.error(f"Ошибка остановки Multi Scalp Bot: {e}")
        else:
            await message.reply_text("⚠️ Multi Asset Scalp Bot не запущен!")
    elif data == 'status_multi_scalp':
        # - ДОБАВЛЕНИЕ 3: Получение статуса через IPC -
        status = await scalp_ipc.get_status()
        if "error" not in status:
            msg = f"⚡ Multi Scalp Bot Status:\n"
            msg += f"Status: {status.get('status', 'unknown')}\n"
            msg += f"Equity: ${status.get('equity', 0):.2f}\n"
            msg += f"Positions: {len(status.get('positions', []))}"
        else:
            msg = f"❌ Ошибка получения статуса: {status['error']}"
        await message.reply_text(msg)
        # - /ДОБАВЛЕНИЕ 3 -
    # - ДОБАВЛЕНИЕ 3: Обработчик для информации о позициях Scalp -
    elif data == 'info_positions_scalp':
        await message.reply_text("⚡ Получение информации о позициях Scalp... ")
        positions_info = await get_positions_info('scalp')
        await message.reply_text(positions_info)
        # - /ДОБАВЛЕНИЕ 3 -

    # Настройки
    elif data == 'settings_menu':
        await message.edit_text("⚙️ Настройки ботов:", reply_markup=settings_menu_keyboard())
    elif data == 'settings_grid_menu':
        await message.edit_text("📉 Grid настройки:", reply_markup=settings_grid_menu_keyboard())
    elif data == 'settings_scalp_menu':
        await message.edit_text("⚡ Scalp настройки:", reply_markup=settings_scalp_menu_keyboard())
    elif data == 'settings_risk_menu':
        await message.edit_text("🛡️ Risk настройки:", reply_markup=settings_risk_menu_keyboard())
    # - ПОДГОТОВКА (Пункт 2): Добавлен комментарий о необходимости FSM -
    elif data.startswith('edit_grid_'):
        param_name = data.replace('edit_grid_', '')
        await message.reply_text(f"⚙️ Функция редактирования {param_name} для Grid бота.\n(Функционал ожидания ответа пользователя (FSM) еще не реализован в этом контроллере. Для изменения параметра, отредактируйте файл конфигурации вручную или доработайте контроллер.)")
    # - /ПОДГОТОВКА (Пункт 2) -
    # - ПОДГОТОВКА (Пункт 2): Добавлен комментарий о необходимости FSM -
    elif data.startswith('edit_scalp_'):
        param_name = data.replace('edit_scalp_', '')
        await message.reply_text(f"⚙️ Функция редактирования {param_name} для Scalp бота.\n(Функционал ожидания ответа пользователя (FSM) еще не реализован в этом контроллере. Для изменения параметра, отредактируйте файл конфигурацию вручную или доработайте контроллер.)")
    # - /ПОДГОТОВКА (Пункт 2) -
    elif data.startswith('edit_risk_'):
        param_name = data.replace('edit_risk_', '')
        await message.reply_text(f"⚙️ Функция редактирования {param_name}.\n(Функционал ожидания ответа пользователя (FSM) еще не реализован в этом контроллере. Для изменения параметра, отредактируйте файл конфигурацию вручную или доработайте контроллер.)")

    # Анализ
    elif data == 'analysis_menu':
        await message.edit_text("📈 Анализ статистики:", reply_markup=analysis_menu_keyboard())
    elif data == 'analyze_multi_grid':
        await message.reply_text("📊 Анализ Multi Grid бота запущен...")
        try:
            result = subprocess.run([sys.executable, 'multi_analyze_stats.py', 'grid'], capture_output=True, text=True, timeout=45)
            if result.returncode == 0:
                await message.reply_text(f"✅ Анализ завершен:\n<pre>{result.stdout}</pre>", parse_mode='HTML')
            else:
                await message.reply_text(f"❌ Ошибка анализа:\n<pre>{result.stderr}</pre>", parse_mode='HTML')
        except subprocess.TimeoutExpired:
            await message.reply_text("⏰ Анализ превысил лимит времени (45 секунд)")
        except Exception as e:
            await message.reply_text(f"❌ Критическая ошибка анализа: {e}")
    elif data == 'analyze_multi_scalp':
        await message.reply_text("⚡ Анализ Multi Scalp бота запущен...")
        try:
            result = subprocess.run([sys.executable, 'multi_analyze_stats.py', 'scalp'], capture_output=True, text=True, timeout=45)
            if result.returncode == 0:
                await message.reply_text(f"✅ Анализ завершен:\n<pre>{result.stdout}</pre>", parse_mode='HTML')
            else:
                await message.reply_text(f"❌ Ошибка анализа:\n<pre>{result.stderr}</pre>", parse_mode='HTML')
        except subprocess.TimeoutExpired:
            await message.reply_text("⏰ Анализ превысил лимит времени (45 секунд)")
        except Exception as e:
            await message.reply_text(f"❌ Критическая ошибка анализа: {e}")

    # Администрирование
    elif data == 'admin_menu':
        if security.is_admin(user_id):
            await message.edit_text("👥 Администрирование:", reply_markup=admin_menu_keyboard())
        else:
            await message.edit_text("🚫 Доступ запрещён.", reply_markup=main_menu_keyboard(user_id))
    elif data == 'add_user' and security.is_admin(user_id):
        await message.reply_text("Введите ID пользователя для добавления (например, /add_user 123456789):")
    elif data == 'remove_user' and security.is_admin(user_id):
        await message.reply_text("Введите ID пользователя для удаления (например, /remove_user 123456789):")
    elif data == 'list_users' and security.is_admin(user_id):
        users = security.get_users()
        if users:
            user_list = "\n".join([f"ID: {u}" for u in users])
            await message.reply_text(f"📋 Список авторизованных пользователей:\n{user_list}")
        else:
            await message.reply_text("📋 Список авторизованных пользователей пуст.")

async def handle_text_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик текстовых сообщений (для админских команд редактирования)"""
    user_id = update.effective_user.id
    if not security.is_admin(user_id):
        return

    text = update.message.text.strip()
    if text.startswith('/add_user'):
        try:
            parts = text.split()
            if len(parts) != 2:
                raise ValueError("Неверный формат команды")
            new_user_id = int(parts[1])
            security.add_user(new_user_id)
            await update.message.reply_text(f"✅ Пользователь {new_user_id} добавлен.")
            logger.info(f"Пользователь {new_user_id} добавлен админом {user_id}")
        except Exception as e:
            await update.message.reply_text(f"❌ Ошибка добавления пользователя: {e}")
    elif text.startswith('/remove_user'):
        try:
            parts = text.split()
            if len(parts) != 2:
                raise ValueError("Неверный формат команды")
            remove_user_id = int(parts[1])
            security.remove_user(remove_user_id)
            await update.message.reply_text(f"✅ Пользователь {remove_user_id} удален.")
            logger.info(f"Пользователь {remove_user_id} удален админом {user_id}")
        except Exception as e:
            await update.message.reply_text(f"❌ Ошибка удаления пользователя: {e}")

# - ДОБАВЛЕНИЕ 1: Функции для получения информации о позициях -
async def get_positions_info(bot_type):
    """Получает информацию о позициях и активных ордерах напрямую с биржи"""
    info_text = ""
    try:
        if not EXCHANGE_INSTANCE:
            return "❌ Невозможно получить данные: API ключи не настроены в контроллере."
        await EXCHANGE_INSTANCE.load_markets()

        if bot_type == 'grid':
            info_text += "📊 Информация о позициях Grid бота: "
            balances = await EXCHANGE_INSTANCE.fetch_balance()
            positions_found = False
            for symbol in SYMBOLS:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_balance = balances['total'].get(base_currency, 0)
                quote_balance = balances['total'].get(quote_currency, 0)
                if base_balance > 1e-8 or quote_balance > 1e-8:
                    info_text += f"\n{symbol}: {base_balance:.6f} {base_currency} + {quote_balance:.2f} {quote_currency}"
                    positions_found = True

            # Получение активных ордеров
            orders_found = False
            for symbol in SYMBOLS:
                try:
                    orders = await EXCHANGE_INSTANCE.fetch_open_orders(symbol)
                    if orders:
                        orders_found = True
                        info_text += f"\n\nАктивные ордера для {symbol}:"
                        for order in orders:
                            side = order['side']
                            price = order['price']
                            amount = order['amount']
                            info_text += f"\n  - {side.upper()} {amount:.6f} @ {price:.2f}"
                except Exception as e:
                    pass
            if not orders_found:
                info_text += "\nНет активных ордеров."

        elif bot_type == 'scalp':
            info_text += "⚡ Информация о позициях Scalp бота: "
            balances = await EXCHANGE_INSTANCE.fetch_balance()
            positions_found = False
            for symbol in SYMBOLS:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_balance = balances['total'].get(base_currency, 0)
                quote_balance = balances['total'].get(quote_currency, 0)
                if base_balance > 1e-8 or quote_balance > 1e-8:
                    info_text += f"\n{symbol}: {base_balance:.6f} {base_currency} + {quote_balance:.2f} {quote_currency}"
                    positions_found = True

            # Получение активных ордеров
            orders_found = False
            for symbol in SYMBOLS:
                try:
                    orders = await EXCHANGE_INSTANCE.fetch_open_orders(symbol)
                    if orders:
                        orders_found = True
                        info_text += f"\n\nАктивные ордера для {symbol}:"
                        for order in orders:
                            side = order['side']
                            price = order['price']
                            amount = order['amount']
                            info_text += f"\n  - {side.upper()} {amount:.6f} @ {price:.2f}"
                except Exception as e:
                    pass
            if not orders_found:
                info_text += "\nНет активных ордеров."

    except Exception as e:
        logger.error(f"Ошибка получения информации о позициях для {bot_type}: {e}")
        return f"❌ Ошибка получения данных: {str(e)}"

    return info_text.strip()
# - /ДОБАВЛЕНИЕ 1 -

async def add_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /add_user"""
    user_id = update.effective_user.id
    if not security.is_admin(user_id):
        await update.message.reply_text("🔒 Доступ запрещён.")
        return
    await update.message.reply_text("Введите ID пользователя для добавления (например, /add_user 123456789):")

async def remove_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /remove_user"""
    user_id = update.effective_user.id
    if not security.is_admin(user_id):
        await update.message.reply_text("🔒 Доступ запрещён.")
        return
    await update.message.reply_text("Введите ID пользователя для удаления (например, /remove_user 123456789):")

# --- Точка входа ---
async def main():
    if not os.path.exists('.env'):
        print("❌ Файл .env не найден!")
        print("Создайте файл .env с вашими API ключами")
        return

    app = Application.builder().token(TELEGRAM_TOKEN).build()

    # Обработчики команд
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("add_user", add_user_command))
    app.add_handler(CommandHandler("remove_user", remove_user_command))

    # Обработчик callback'ов от кнопок
    app.add_handler(CallbackQueryHandler(button_handler))

    # Обработчик текстовых сообщений (для админских команд редактирования)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_input))

    # Инициализация IPC клиентов
    # await init_ipc_clients(app) # Инициализация IPC клиентов

    # Добавляем мониторинг процессов
    app.job_queue.run_repeating(monitor_bots, interval=45, first=10)

    # Запуск бота
    logger.info("🎯 Multi Asset Bot Controller запущен")
    await app.run_polling()

if __name__ == '__main__':
    asyncio.run(main())


# v2.0 (+правки из анализа: кэширование баланса, дедупликация логов, исправления, capital_distributor)
"""
Базовый класс для торговых ботов.
v2.0: Добавлено кэширование баланса, дедупликация логов, исправлен check_min_lot, интеграция capital_distributor.
"""
import ccxt.async_support as ccxt
import asyncio
import time
import logging
import signal
import os
import sys
import json
import math
import collections
from datetime import datetime, timedelta
from telegram import Bot
from dotenv import load_dotenv
# - ДОБАВЛЕНИЕ 1: Импорт log_helper -
from log_helper import build_logger
# - /ДОБАВЛЕНИЕ 1 -
# - ДОБАВЛЕНИЕ 2: Импорт ConfigManager -
from config_manager import ConfigManager
# - /ДОБАВЛЕНИЕ 2 -
# - ДОБАВЛЕНИЕ 4: Импорт dataclasses для TradeEvent -
from dataclasses import dataclass
# - /ДОБАВЛЕНИЕ 4 -

load_dotenv()
os.makedirs('logs', exist_ok=True)

# === v2.0: Исправления и дополнения из чек-листа ===
# - Добавлено кэширование баланса
# - Добавлена дедупликация логов
# - Исправлен метод check_min_lot (ИСПРАВЛЕНИЕ 1)
# - Абстрактный метод close_all_positions для обязательной реализации
# === /v2.0 ===

# - ДОБАВЛЕНИЕ 4: Определение TradeEvent -
@dataclass
class TradeEvent:
    """Событие сделки"""
    ts: float
    symbol: str
    side: str  # buy/sell
    price: float
    qty: float
    pnl: float = 0.0
# - /ДОБАВЛЕНИЕ 4 -

class BaseTradingBot:
    """
    Базовый класс для торговых ботов.
    v2.0: Добавлено кэширование баланса, дедупликация логов, исправлен check_min_lot, интеграция capital_distributor.
    """

    def __init__(self, bot_type: str):
        """
        Базовый класс для торговых ботов.
        :param bot_type: Тип бота ('grid' или 'scalp')
        """
        self.bot_type = bot_type
        
        # - ДОБАВЛЕНИЕ 1: Используем log_helper для персонального лог-файла -
        self.logger = build_logger(f"{bot_type}_bot")
        # - /ДОБАВЛЕНИЕ 1 -
        
        # - ДОБАВЛЕНИЕ 2: Загрузка конфигурации через ConfigManager -
        self.config_manager = ConfigManager()
        self.config = self.config_manager.get_config()
        # - /ДОБАВЛЕНИЕ 2 -
        
        # Инициализация биржи
        API_KEY = os.getenv('API_KEY')
        API_SECRET = os.getenv('API_SECRET')
        PASSPHRASE = os.getenv('PASSPHRASE')
        if not all([API_KEY, API_SECRET, PASSPHRASE]):
            raise ValueError("❌ Отсутствуют обязательные переменные окружения (API_KEY, API_SECRET, PASSPHRASE)")
            
        self.ex = ccxt.okx({
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'password': PASSPHRASE,
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'},
            'sandbox': True  # Используем демо-режим
        })
        
        # Инициализация Telegram бота
        TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
        if not TELEGRAM_TOKEN:
            raise ValueError("❌ TELEGRAM_TOKEN не найден в .env")
        self.tg_bot = Bot(token=TELEGRAM_TOKEN)
        
        # Настройки из конфига
        self.symbols = self.config.get('symbols', ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'SOL/USDT', 'XRP/USDT', 'ADA/USDT', 'DOT/USDT'])
        self.chat_ids = self.config.get('chat_ids', [462885677, 5954433829])
        
        # Состояние бота
        self.running = True
        self.last_notification = 0
        
        # Капитал
        self.total_capital = 0
        self.working_capital = 0
        self.reserve_capital = 0
        self.allocated_capital = {}  # {symbol: float}
        self.last_redistribution = 0
        self.redistribution_interval = self.config.get('redistribution_interval', 1800)  # 30 минут
        
        # - ДОБАВЛЕНИЕ 6: Буфер для сделок за 24 часа -
        self.trades_24h: list[TradeEvent] = []
        # - /ДОБАВЛЕНИЕ 6 -
        
        # Установка обработчиков сигналов
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        # === v2.0: Добавлено кэширование баланса ===
        self._balance_cache = {'data': None, 'time': 0}
        # === /v2.0: Добавлено кэширование баланса ===
        
        # === v2.0: Добавлена дедупликация логов ===
        self._last_log_msg = ""
        # === /v2.0: Добавлена дедупликация логов ===

    async def send(self, msg):
        """Отправка сообщения в Telegram"""
        now = time.time()
        if now - self.last_notification < 2:
            await asyncio.sleep(2 - (now - self.last_notification))
        self.last_notification = now
        for cid in self.chat_ids:
            try:
                await self.tg_bot.send_message(chat_id=cid, text=msg)
            except Exception as e:
                self.logger.error(f"Ошибка отправки в Telegram: {e}")

    # === v2.0: Обновлен метод get_balances с кэшированием ===
    async def get_balances(self):
        """
        Получение балансов для всех символов с кэшированием.
        v2.0: Добавлено кэширование баланса с TTL из конфига.
        """
        # === v2.0: Используем кэш баланса ===
        cache_ttl = self.config.get('balance_cache_sec', 60)
        current_time = time.time()
        
        if (self._balance_cache['data'] is not None and
            current_time - self._balance_cache['time'] < cache_ttl):
            self.logger.debug("📊 Использован кэш баланса")
            return self._balance_cache['data']
        # === /v2.0: Используем кэш баланса ===
        
        try:
            # - ИСПРАВЛЕНИЕ 1: Получаем баланс ОДИН РАЗ -
            bal = await self.ex.fetch_balance({'type': 'spot'})
            # - /ИСПРАВЛЕНИЕ 1 -
            balances = {}
            for symbol in self.symbols:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_free = bal['free'].get(base_currency, 0)
                base_total = bal['total'].get(base_currency, 0)
                quote_free = bal['free'].get(quote_currency, 0)
                quote_total = bal['total'].get(quote_currency, 0)
                balances[symbol] = {
                    'base': base_total,
                    'quote': quote_total,
                    'free_base': base_free,
                    'free_quote': quote_free
                }
            # === v2.0: Обновляем кэш ===
            self._balance_cache['data'] = balances
            self._balance_cache['time'] = current_time
            # === /v2.0: Обновляем кэш ===
            return balances
        except Exception as e:
            self.logger.error(f"Ошибка получения балансов: {e}")
            # Возвращаем пустой словарь или старый кэш в случае ошибки?
            return self._balance_cache['data'] if self._balance_cache['data'] else {}
    # === /v2.0: Обновлен метод get_balances ===

    async def update_capital(self):
        """Обновление информации о капитале"""
        try:
            balances = await self.get_balances()
            self.total_capital = 0
            for symbol in self.symbols:
                symbol_balance = balances.get(symbol, {'base': 0, 'quote': 0})
                try:
                    ticker = await self.ex.fetch_ticker(symbol)
                    price = ticker['last']
                    # Рассчитываем эквити для символа: (базовый актив * цена) + котируемая валюта
                    base_equity = symbol_balance['base'] * price
                    quote_equity = symbol_balance['quote']
                    equity = base_equity + quote_equity
                    self.total_capital += equity
                    # - ИСПРАВЛЕНИЕ 2: Исправлена ошибка форматирования -
                    self.logger.debug(f"💰 {symbol}: {symbol_balance['base']:.6f} {symbol.split('/')[0]} + {symbol_balance['quote']:.2f} {symbol.split('/')[1]} ≈ {equity:.2f} USDT")
                    # - /ИСПРАВЛЕНИЕ 2 -
                except Exception as e:
                    self.logger.warning(f"Не удалось получить цену для {symbol} при обновлении капитала: {e}")
            
            self.logger.info(f"💰 Обновлен капитал: Всего=${self.total_capital:.2f} USDT")
        except Exception as e:
            self.logger.error(f"❌ Критическая ошибка обновления капитала: {e}")
    # - /ИСПРАВЛЕНИЕ -

    # - ИСПРАВЛЕНИЕ 1: Защита метода check_min_lot от NoneType -
    async def check_min_lot(self, symbol, amount, price):
        """
        Проверка соответствия минимальным требованиям биржи с защитой от None.
        v2.0: Исправлена ошибка с None market_info (ИСПРАВЛЕНИЕ 1).
        """
        try:
            # 1. Получаем информацию о рынке
            market_info = self.ex.market(symbol)
            
            # === v2.0: Исправление 1 - Добавлена защита от None ===
            if not market_info:
                self.logger.warning(f"⚠️ {symbol}: Не удалось получить информацию о рынке")
                return False
            # === /v2.0: Исправление 1 ===
            
            # 2. Получаем минимальные значения из конфигурации рынка
            min_amount = market_info.get('limits', {}).get('amount', {}).get('min', 0)
            min_cost = market_info.get('limits', {}).get('cost', {}).get('min', 0)
            
            # 3. Проверяем минимальный объем
            if amount < min_amount:
                self.logger.info(f"⚠️ {symbol}: Объем {amount} < минимального {min_amount}")
                return False
                
            # 4. Проверяем минимальную стоимость
            cost = amount * price
            if cost < min_cost:
                self.logger.info(f"⚠️ {symbol}: Стоимость {cost:.4f} < минимальной {min_cost}")
                return False
                
            return True
        except Exception as e:
            self.logger.error(f"Ошибка проверки минимального лота для {symbol}: {e}")
            return False # В случае ошибки считаем проверку не пройденной
    # - /ИСПРАВЛЕНИЕ 1 -

    # - ДОБАВЛЕНИЕ 1: Метод логирования сделок -
    async def log_trade(self, event: TradeEvent):
        """Логирование сделки. v2.0: Исправлена дедупликация."""
        msg = (f"{event.symbol} <b>{'ОТКРЫТИЕ' if event.pnl == 0 else 'ЗАКРЫТИЕ'}</b>\n"
               f"💰 Цена: <code>{event.price:.4f}</code>\n"
               f"📦 Объём: <code>{event.qty:.4f}</code>")
        if event.pnl != 0:
            msg += f"\n📊 PnL: <code>{event.pnl:.2f}</code> $"
            
        # === v2.0: Добавлена дедупликация логов ===
        if msg == self._last_log_msg:
            return # Не отправляем идентичные сообщения подряд
        self._last_log_msg = msg
        # === /v2.0: Добавлена дедупликация логов ===
            
        self.logger.info(msg.replace('<b>', '').replace('</code>', ''))
        await self.send(msg)
        
        # - ДОБАВЛЕНИЕ 6: Сохраняем сделку в буфер -
        self.trades_24h.append(event)
        # - /ДОБАВЛЕНИЕ 6 -
    # - /ДОБАВЛЕНИЕ 1 -

    # - ДОБАВЛЕНИЕ 11: Метод логирования снапшота портфеля -
    async def _log_portfolio_snapshot(self):
        """Логирование снапшота портфеля"""
        try:
            balances = await self.get_balances()
            lines = [f"📈 <b>Портфель {self.bot_type.upper()}</b> {datetime.utcnow():%d.%m %H:%M} UTC"]
            total_eq = 0
            for s in self.symbols:
                base, quote = balances[s]['base'], balances[s]['quote']
                try:
                    price = (await self.ex.fetch_ticker(s))['last']
                    eq = base * price + quote
                    total_eq += eq
                    lines.append(f"{s}: {base:.4f} + {quote:.2f} ≈ <code>{eq:.2f}</code> $")
                except Exception as e:
                    self.logger.warning(f"Не удалось получить цену для {s} в снапшоте: {e}")
                    lines.append(f"{s}: {base:.4f} + {quote:.2f} (Цена недоступна)")
            lines.append(f"💰 Всего: <code>{total_eq:.2f}</code> $")
            msg = "\n".join(lines)
            self.logger.info(msg.replace('<b>', '').replace('</b>', '').replace('<code>', '').replace('</code>', ''))
            await self.send(msg)
        except Exception as e:
            self.logger.error(f"Ошибка логирования снапшота портфеля: {e}")
    # - /ДОБАВЛЕНИЕ 11 -

    # - ДОБАВЛЕНИЕ 12: Метод отправки ежедневного отчета -
    async def _send_daily_summary(self):
        """Отправка ежедневного отчета"""
        try:
            # - ДОБАВЛЕНИЕ 6: Анализируем сделки за последние 24 часа -
            trades = self.trades_24h
            total, wins, losses = len(trades), 0, 0
            gross_pnl = 0.0
            for t in trades:
                gross_pnl += t.pnl
                if t.pnl > 0:
                    wins += 1
                else:
                    losses += 1
            win_rate = wins / total * 100 if total else 0
            # - /ДОБАВЛЕНИЕ 6 -
            await self.update_capital()
            msg = (f"📊 <b>Отчёт за {datetime.utcnow():%d.%m.%Y}</b>\n"
                   f"💰 Equity: <code>{self.total_capital:.2f}</code> $\n"
                   f"📈 Сделок: {total} (W: {wins} / L: {losses})\n"
                   f"🎯 Вин-рейт: {win_rate:.1f}%\n"
                   f"💵 PnL: <code>{gross_pnl:.2f}</code> $")
            self.logger.info(msg.replace('<b>', '').replace('</b>', '').replace('<code>', '').replace('</code>', ''))
            await self.send(msg)
        except Exception as e:
            self.logger.error(f"Ошибка отправки ежедневного отчета: {e}")
    # - /ДОБАВЛЕНИЕ 12 -

    # - ДОБАВЛЕНИЕ 13: Цикл ежедневного отчета -
    async def _daily_report_loop(self):
        """Цикл отправки ежедневного отчета"""
        while self.running:
            # Ждем до следующего полночи UTC
            now = datetime.utcnow()
            next_midnight = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
            sleep_seconds = (next_midnight - now).total_seconds()
            self.logger.info(f"Следующий ежедневный отчет через {sleep_seconds / 3600:.2f} часов")
            await asyncio.sleep(sleep_seconds)
            if not self.running:
                break
            await self._send_daily_summary()
            self.trades_24h.clear() # - ДОБАВЛЕНИЕ 6: Очищаем буфер после отчета -
    # - /ДОБАВЛЕНИЕ 13 -

    async def distribute_capital(self):
        """
        Абстрактный метод для распределения капитала. Должен быть реализован в дочерних классах.
        v2.0: Обновлен комментарий.
        """
        self.logger.info(f"🔄 Начало перераспределения капитала для {self.bot_type}...")
        # Базовая реализация: равное распределение
        total_allocated = 0
        base_capital_per_symbol = self.working_capital / len(self.symbols)
        for symbol in self.symbols:
            allocated_capital = base_capital_per_symbol
            # Проверяем лимит экспозиции
            exposure_limit = self.config.get(self.bot_type, {}).get('exposure_limit', 1.0)
            max_allowed_for_symbol = self.total_capital * exposure_limit
            if allocated_capital > max_allowed_for_symbol:
                allocated_capital = max_allowed_for_symbol
                self.logger.info(f"⚠️ {symbol}: Превышен лимит экспозиции, скорректировано до ${allocated_capital:.2f}")
                
            self.allocated_capital[symbol] = allocated_capital
            total_allocated += allocated_capital
            self.logger.info(f"💰 {symbol}: выделено ${allocated_capital:.2f}")
            
        # Обновляем резервный капитал
        self.reserve_capital = self.total_capital - total_allocated
        max_allowed_reserve = self.total_capital * 0.5
        if self.reserve_capital > max_allowed_reserve:
            self.reserve_capital = max_allowed_reserve
        self.logger.info(f"💰 Обновлен резерв: ${self.reserve_capital:.2f} (макс. {max_allowed_reserve:.2f})")
        self.logger.info(f"✅ Перераспределение капитала для {self.bot_type} завершено.")

    async def run(self):
        """Основной цикл работы бота"""
        try:
            await self.ex.load_markets()
            await self.update_capital()
            
            # Инициализация капитала
            self.working_capital = self.total_capital * 0.5
            self.reserve_capital = self.total_capital * 0.5
            self.logger.info(f"💰 Инициализация капитала: Всего=${self.total_capital:.2f}, Рабочий=${self.working_capital:.2f}, Резерв=${self.reserve_capital:.2f}")
            
            # Начальное распределение капитала
            await self.distribute_capital()
            
            # - ИСПРАВЛЕНИЕ 1: Запуск цикла ежедневного отчета -
            asyncio.create_task(self._daily_report_loop())
            # - /ИСПРАВЛЕНИЕ 1 -
            
            self.logger.info(f"🟢 {self.bot_type.capitalize()} Bot запущен. Начальный капитал: {self.total_capital:.2f} USDT")
            await self.send(f"🟢 {self.bot_type.capitalize()} Bot запущен. Капитал: {self.total_capital:.2f} USDT")
            
            # Основной цикл
            while self.running:
                try:
                    await self.update_capital()
                    
                    # Периодическое перераспределение капитала
                    current_time = time.time()
                    if current_time - self.last_redistribution > self.redistribution_interval:
                        await self.distribute_capital()
                        self.last_redistribution = current_time
                        
                    # - ИСПРАВЛЕНИЕ 2: Снапшот портфеля каждые 5 минут -
                    if int(time.time()) % 300 == 0:
                        await self._log_portfolio_snapshot()
                    # - /ИСПРАВЛЕНИЕ 2 -
                    
                    # Специфичная логика бота
                    await self.execute_strategy()
                    
                    # Пауза
                    sleep_interval = self.config[self.bot_type]['sleep_interval']
                    await asyncio.sleep(sleep_interval)
                    
                except ccxt.NetworkError as e:
                    self.logger.error(f"Сетевая ошибка: {e}")
                    await asyncio.sleep(10)
                except ccxt.ExchangeError as e:
                    self.logger.error(f"Биржевая ошибка: {e}")
                    await asyncio.sleep(sleep_interval * 2)
                except Exception as e:
                    self.logger.error(f"❌ Критическая ошибка в основном цикле {self.bot_type}: {e}")
                    await asyncio.sleep(sleep_interval * 3)
                    
        except Exception as e:
            self.logger.error(f"Критическая ошибка: {e}")
        finally:
            await self._shutdown()

    async def execute_strategy(self):
        """
        Абстрактный метод для выполнения торговой стратегии. Должен быть реализован в дочерних классах.
        """
        raise NotImplementedError("Метод 'execute_strategy' должен быть реализован в дочернем классе")

    # v2.0: Добавлен абстрактный метод close_all_positions
    async def close_all_positions(self):
        """
        Абстрактный метод для закрытия всех позиций.
        v2.0: Добавлен как абстрактный метод.
        """
        raise NotImplementedError("Метод 'close_all_positions' должен быть реализован в дочернем классе")

    async def _shutdown(self):
        """
        Graceful shutdown для базового бота.
        v2.0: Добавлен вызов close_all_positions.
        """
        self.logger.info(f"🛑 {self.bot_type.capitalize()} graceful shutdown...")
        try:
            await self.close_all_positions()
        except Exception as e:
            self.logger.error(f"Ошибка при закрытии позиций во время shutdown: {e}")
        self.running = False

    def exit_gracefully(self, signum, frame):
        """Обработчик сигналов для graceful shutdown"""
        self.logger.info(f"🛑 {self.bot_type.capitalize()} graceful shutdown (сигнал {signum})")
        self.running = False


# v2.0 (+правки из анализа: логирование сделок, исправления обработки ошибок, закрытие позиций, capital_distributor)
"""
Multi-Asset Scalping Trading Bot.
v2.0: Добавлено логирование сделок, исправлены ошибки обработки, добавлено закрытие позиций, интеграция capital_distributor.
"""
import ccxt.async_support as ccxt
import numpy as np
import talib
import asyncio
import time
import logging
import signal
import sys
import os
import json
import math
import collections
from datetime import datetime, timedelta
from telegram import Bot
from dotenv import load_dotenv
# - ДОБАВЛЕНИЕ 1: Импорт log_helper -
from log_helper import build_logger
# - /ДОБАВЛЕНИЕ 1 -
# - ДОБАВЛЕНИЕ 2: Импорт ConfigManager -
from config_manager import ConfigManager
# - /ДОБАВЛЕНИЕ 2 -
# - ДОБАВЛЕНИЕ 3: Импорт IPC сервера -
from ipc import ScalpBotIPCServer
# - /ДОБАВЛЕНИЕ 3 -
# - ДОБАВЛЕНИЕ 4: Импорт dataclasses для TradeEvent -
from dataclasses import dataclass
# - /ДОБАВЛЕНИЕ 4 -
# v2.0: Импорт нового модуля распределения капитала
from capital_distributor import CapitalDistributor

load_dotenv()
os.makedirs('logs', exist_ok=True)

# === v2.0: Исправления и дополнения из чек-листа ===
# - Добавлено логирование сделок
# - Исправлены ошибки обработки тренда, спреда и рынка (ИСПРАВЛЕНИЕ 18)
# - Добавлен graceful shutdown с закрытием позиций
# - Использование CapitalDistributor для распределения капитала
# === /v2.0 ===

# - ДОБАВЛЕНИЕ 4: Определение TradeEvent -
@dataclass
class TradeEvent:
    ts: float
    symbol: str
    side: str  # buy/sell
    price: float
    qty: float
    pnl: float = 0.0
# - /ДОБАВЛЕНИЕ 4 -

class MultiAssetScalpBot:
    """
    Multi-Asset Scalping Trading Bot.
    v2.0: Добавлено логирование сделок, исправлены ошибки обработки, добавлено закрытие позиций, интеграция capital_distributor.
    """

    def __init__(self):
        # - ДОБАВЛЕНИЕ 1: Используем log_helper для персонального лог-файла -
        self.logger = build_logger("scalp_bot")
        # - /ДОБАВЛЕНИЕ 1 -
        
        # - ДОБАВЛЕНИЕ 2: Загрузка конфигурации через ConfigManager -
        self.config_manager = ConfigManager()
        self.config = self.config_manager.get_config()
        # - /ДОБАВЛЕНИЕ 2 -
        
        # Инициализация биржи
        API_KEY = os.getenv('API_KEY')
        API_SECRET = os.getenv('API_SECRET')
        PASSPHRASE = os.getenv('PASSPHRASE')
        if not all([API_KEY, API_SECRET, PASSPHRASE]):
            raise ValueError("❌ Отсутствуют обязательные переменные окружения: API_KEY, API_SECRET, PASSPHRASE")
            
        self.ex = ccxt.okx({
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'password': PASSPHRASE,
            'sandbox': True,  # Используем демо-режим
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        
        self.symbols = self.config['symbols']
        self.chat_ids = self.config['chat_ids']
        self.tg_bot = Bot(token=os.getenv('TELEGRAM_BOT_TOKEN'))
        self.running = True
        self.last_notification = 0
        
        # Состояние капитала
        self.total_capital = 0
        self.working_capital = 0
        self.reserve_capital = 0
        self.allocated_capital = {}  # {symbol: float}
        self.last_redistribution = 0
        self.redistribution_interval = self.config.get('redistribution_interval', 1800)  # 30 минут
        
        # Состояние Scalp-бота
        self.positions = {}  # {symbol: {'side': 'long'/'short', 'amount': float, 'entry': float, 'timestamp': float}}
        self.last_signal_times = {}
        self.consecutive_losses = {}
        
        # - ДОБАВЛЕНИЕ 10: Параметры из конфига -
        cfg = self.config['scalp']['indicators']
        self.rsi_period = cfg['rsi']['timeperiod']
        self.stoch_fk = cfg['stoch']['fastk_period']
        self.stoch_sk = cfg['stoch']['slowk_period']
        self.stoch_smatype = cfg['stoch']['slowk_matype']
        self.stoch_sd = cfg['stoch']['slowd_period']
        self.stoch_smatype = cfg['stoch']['slowd_matype']
        self.macd_f = cfg['macd']['fastperiod']
        self.macd_s = cfg['macd']['slowperiod']
        self.macd_sig = cfg['macd']['signalperiod']
        self.ema_short = cfg['ema']['short_period']
        self.ema_long = cfg['ema']['long_period']
        self.atr_period = cfg['atr']['timeperiod']
        # - /ДОБАВЛЕНИЕ 10 -
        
        # Установка обработчиков сигналов
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        # - ДОБАВЛЕНИЕ 3: Инициализация IPC сервера -
        self.ipc_server = ScalpBotIPCServer(self) if self.config.get('ipc_enabled', True) else None
        # - /ДОБАВЛЕНИЕ 3 -
        
        # - ДОБАВЛЕНИЕ 5: Параметры TP/SL из конфига -
        self.tp_pct = self.config['scalp'].get('tp_pct', 0.15) / 100
        self.sl_pct = self.config['scalp'].get('sl_pct', 0.25) / 100
        self.fee_rate = self.config['scalp'].get('fee_rate', 0.001)
        self.max_hold_seconds = self.config['scalp'].get('max_hold_seconds', 180)
        # - /ДОБАВЛЕНИЕ 5 -

    async def send(self, msg):
        """Отправка сообщения в Telegram"""
        now = time.time()
        if now - self.last_notification < 2:
            await asyncio.sleep(2 - (now - self.last_notification))
        self.last_notification = now
        for cid in self.chat_ids:
            try:
                await self.tg_bot.send_message(chat_id=cid, text=msg)
            except Exception as e:
                self.logger.error(f"Ошибка отправки в Telegram: {e}")

    # - ИСПРАВЛЕНИЕ: Корректный метод получения балансов -
    async def get_balances(self):
        """Получение балансов для всех символов"""
        try:
            # - ИСПРАВЛЕНИЕ 1: Получаем баланс ОДИН РАЗ -
            bal = await self.ex.fetch_balance({'type': 'spot'})
            # - /ИСПРАВЛЕНИЕ 1 -
            balances = {}
            for symbol in self.symbols:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_free = bal['free'].get(base_currency, 0)
                base_total = bal['total'].get(base_currency, 0)
                quote_free = bal['free'].get(quote_currency, 0)
                quote_total = bal['total'].get(quote_currency, 0)
                balances[symbol] = {
                    'base': base_total,
                    'quote': quote_total,
                    'free_base': base_free,
                    'free_quote': quote_free
                }
            return balances
        except Exception as e:
            self.logger.error(f"Ошибка получения балансов: {e}")
            return {}
    # - /ИСПРАВЛЕНИЕ -

    async def update_capital(self):
        """Обновление информации о капитале"""
        try:
            balances = await self.get_balances()
            self.total_capital = 0
            for symbol in self.symbols:
                symbol_balance = balances.get(symbol, {'base': 0, 'quote': 0})
                try:
                    ticker = await self.ex.fetch_ticker(symbol)
                    price = ticker['last']
                    # Рассчитываем эквити для символа
                    base_equity = symbol_balance['base'] * price
                    quote_equity = symbol_balance['quote']
                    equity = base_equity + quote_equity
                    self.total_capital += equity
                    # - ИСПРАВЛЕНИЕ 2: Исправлена ошибка форматирования -
                    self.logger.debug(f"💰 {symbol}: {symbol_balance['base']:.6f} {symbol.split('/')[0]} + {symbol_balance['quote']:.2f} {symbol.split('/')[1]} ≈ {equity:.2f} USDT")
                    # - /ИСПРАВЛЕНИЕ 2 -
                except Exception as e:
                    self.logger.warning(f"Не удалось получить цену для {symbol} при обновлении капитала: {e}")
            
            self.logger.info(f"💰 Обновлен капитал: Всего=${self.total_capital:.2f} USDT")
        except Exception as e:
            self.logger.error(f"❌ Критическая ошибка обновления капитала: {e}")
    # - /ИСПРАВЛЕНИЕ -

    # - ИСПРАВЛЕНИЕ 1: Защита метода check_min_lot от NoneType -
    async def check_min_lot(self, symbol, amount, price):
        """
        Проверка соответствия минимальным требованиям биржи с защитой от None.
        """
        try:
            # 1. Получаем информацию о рынке
            market_info = self.ex.market(symbol)
            
            # === v2.0: Исправление 1 - Добавлена защита от None ===
            if not market_info:
                self.logger.warning(f"⚠️ {symbol}: Не удалось получить информацию о рынке")
                return False
            # === /v2.0: Исправление 1 ===
            
            # 2. Получаем минимальные значения из конфигурации рынка
            min_amount = market_info.get('limits', {}).get('amount', {}).get('min', 0)
            min_cost = market_info.get('limits', {}).get('cost', {}).get('min', 0)
            
            # 3. Проверяем минимальный объем
            if amount < min_amount:
                self.logger.info(f"⚠️ {symbol}: Объем {amount} < минимального {min_amount}")
                return False
                
            # 4. Проверяем минимальную стоимость
            cost = amount * price
            if cost < min_cost:
                self.logger.info(f"⚠️ {symbol}: Стоимость {cost:.4f} < минимальной {min_cost}")
                return False
                
            return True
        except Exception as e:
            self.logger.error(f"Ошибка проверки минимального лота для {symbol}: {e}")
            return False # В случае ошибки считаем проверку не пройденной
    # - /ИСПРАВЛЕНИЕ 1 -

    # v2.0: Исправление 18 - Добавлена защита от исключений
    async def trend_filter(self, symbol):
        """Фильтр тренда на основе EMA200. v2.0: Исправление 18."""
        try:
            # Получаем данные 1h
            ohlcv_1h = await self.ex.fetch_ohlcv(symbol, '1h', limit=210)
            if len(ohlcv_1h) < 200:
                self.logger.warning(f"⚠️ {symbol}: Недостаточно данных для тренд-фильтра (1h)")
                return True  # Если данных мало, не блокируем

            closes_1h = np.array([candle[4] for candle in ohlcv_1h])

            # Проверка на NaN
            if np.any(np.isnan(closes_1h)):
                self.logger.warning(f"⚠️ {symbol}: NaN в данных OHLCV для тренд-фильтра")
                return True  # Если данные повреждены, не блокируем

            ema_200 = talib.EMA(closes_1h, timeperiod=200)
            if len(ema_200) == 0 or np.isnan(ema_200[-1]):
                return True  # Если EMA не рассчиталась, не блокируем

            current_price = closes_1h[-1]
            # Тренд восходящий, если цена выше EMA200
            is_favorable = current_price > ema_200[-1]

            if not is_favorable:
                self.logger.info(f"⚠️ {symbol}: Нисходящий тренд (Цена {current_price:.2f} < EMA200 {ema_200[-1]:.2f})")

            return is_favorable

        # === v2.0: Исправление 18 - Добавлена защита от исключений ===
        except Exception as e:
            self.logger.error(f"Ошибка тренд-фильтра для {symbol}: {e}")
            return True  # В случае ошибки не блокируем
        # === /v2.0: Исправление 18 ===

    # v2.0: Исправление 18 - Добавлена защита от исключений
    async def is_spread_acceptable(self, symbol):
        """Проверка спреда. v2.0: Исправление 18."""
        try:
            ticker = await self.ex.fetch_ticker(symbol)
            bid = ticker['bid']
            ask = ticker['ask']

            if bid is None or ask is None or bid <= 0 or ask <= 0:
                return False

            spread_pct = (ask - bid) / bid
            # Спред должен быть меньше 0.1% (0.001)
            return spread_pct < 0.001
        # === v2.0: Исправление 18 - Добавлена защита от исключений ===
        except Exception as e:
            self.logger.error(f"Ошибка проверки спреда для {symbol}: {e}")
            return False  # В случае ошибки считаем спред неприемлемым
        # === /v2.0: Исправление 18 ===

    # v2.0: Исправление 18 - Добавлена защита от исключений
    async def analyze_market_regime(self, symbol):
        """Анализ рыночного режима для адаптивного скальпинга. v2.0: Исправление 18."""
        try:
            # Получаем данные с разных таймфреймов
            ohlcv_5m = await self.ex.fetch_ohlcv(symbol, '5m', limit=50)
            ohlcv_15m = await self.ex.fetch_ohlcv(symbol, '15m', limit=50)

            if len(ohlcv_5m) < 20 or len(ohlcv_15m) < 20:
                return 0, {}

            closes_5m = np.array([x[4] for x in ohlcv_5m])
            highs_5m = np.array([x[2] for x in ohlcv_5m])
            lows_5m = np.array([x[3] for x in ohlcv_5m])
            volumes_5m = np.array([x[5] for x in ohlcv_5m])

            # Проверка на NaN
            if np.any(np.isnan(closes_5m)) or np.any(np.isnan(highs_5m)) or np.any(np.isnan(lows_5m)):
                self.logger.warning(f"⚠️ {symbol}: NaN в данных OHLCV для анализа рынка")
                return 0, {}

            # RSI
            # - ДОБАВЛЕНИЕ: Используем параметр из конфига -
            rsi = talib.RSI(closes_5m, timeperiod=self.rsi_period)
            # - /ДОБАВЛЕНИЕ -
            rsi_value = rsi[-1] if len(rsi) > 0 and not np.isnan(rsi[-1]) else 50

            # Stochastic
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            stoch_k, stoch_d = talib.STOCH(highs_5m, lows_5m, closes_5m,
                                          fastk_period=self.stoch_fk,
                                          slowk_period=self.stoch_sk,
                                          slowk_matype=self.stoch_smatype,
                                          slowd_period=self.stoch_sd,
                                          slowd_matype=self.stoch_smatype)
            # - /ДОБАВЛЕНИЕ -
            stoch_k_val = stoch_k[-1] if len(stoch_k) > 0 and not np.isnan(stoch_k[-1]) else 50
            stoch_d_val = stoch_d[-1] if len(stoch_d) > 0 and not np.isnan(stoch_d[-1]) else 50

            # MACD
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            macd, macdsignal, macdhist = talib.MACD(closes_5m,
                                                   fastperiod=self.macd_f,
                                                   slowperiod=self.macd_s,
                                                   signalperiod=self.macd_sig)
            # - /ДОБАВЛЕНИЕ -
            macd_value = macdhist[-1] if len(macdhist) > 0 and not np.isnan(macdhist[-1]) else 0

            # Объем (OBV delta)
            obv = talib.OBV(closes_5m, volumes_5m)
            if len(obv) >= 2:
                obv_delta = obv[-1] - obv[-2]
                # Нормализуем OBV delta
                avg_volume = np.mean(volumes_5m[-20:]) if len(volumes_5m) >= 20 else 1
                obv_delta_norm = obv_delta / avg_volume if avg_volume > 0 else 0
            else:
                obv_delta_norm = 0

            # Взвешиваем сигналы
            rsi_signal = 0
            if rsi_value < 30:
                rsi_signal = 1
            elif rsi_value > 70:
                rsi_signal = -1

            stoch_signal = 0
            if stoch_k_val < 20 and stoch_d_val < 20:
                stoch_signal = 1
            elif stoch_k_val > 80 and stoch_d_val > 80:
                stoch_signal = -1

            macd_signal = 0
            if macd_value > 0:
                macd_signal = 1
            elif macd_value < 0:
                macd_signal = -1

            obv_signal = 0
            if obv_delta_norm > 0.1:
                obv_signal = 1
            elif obv_delta_norm < -0.1:
                obv_signal = -1

            # Финальный сигнал
            total_signal = (rsi_signal * 0.25 + stoch_signal * 0.25 + macd_signal * 0.25 + obv_signal * 0.25) * 100

            indicators = {
                'rsi': rsi_value,
                'stoch_k': stoch_k_val,
                'stoch_d': stoch_d_val,
                'macd_hist': macd_value,
                'obv_delta_norm': obv_delta_norm
            }

            return total_signal, indicators

        # === v2.0: Исправление 18 - Добавлена защита от исключений ===
        except Exception as e:
            self.logger.error(f"Ошибка анализа рынка для {symbol}: {e}")
            return 0, {}  # В случае ошибки возвращаем нейтральный сигнал
        # === /v2.0: Исправление 18 ===

    async def combo_strategy(self, symbol):
        """Комбинированная стратегия"""
        try:
            # Получаем данные
            ohlcv_5m = await self.ex.fetch_ohlcv(symbol, '5m', limit=50)
            ohlcv_15m = await self.ex.fetch_ohlcv(symbol, '15m', limit=50)
            
            if len(ohlcv_5m) < 20 or len(ohlcv_15m) < 20:
                return 0
                
            closes_5m = np.array([x[4] for x in ohlcv_5m])
            highs_5m = np.array([x[2] for x in ohlcv_5m])
            lows_5m = np.array([x[3] for x in ohlcv_5m])
            volumes_5m = np.array([x[5] for x in ohlcv_5m])
            
            # Проверка на NaN
            if np.any(np.isnan(closes_5m)) or np.any(np.isnan(highs_5m)) or np.any(np.isnan(lows_5m)):
                self.logger.warning(f"NaN в данных OHLCV для {symbol} в combo_strategy")
                return 0
                
            # RSI (5m)
            # - ДОБАВЛЕНИЕ: Используем параметр из конфига -
            rsi_5m = talib.RSI(closes_5m, timeperiod=self.rsi_period)
            # - /ДОБАВЛЕНИЕ -
            rsi_val_5m = rsi_5m[-1] if len(rsi_5m) > 0 and not np.isnan(rsi_5m[-1]) else 50
            
            # Stochastic (5m)
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            stoch_k_5m, stoch_d_5m = talib.STOCH(highs_5m, lows_5m, closes_5m,
                                                fastk_period=self.stoch_fk,
                                                slowk_period=self.stoch_sk,
                                                slowk_matype=self.stoch_smatype,
                                                slowd_period=self.stoch_sd,
                                                slowd_matype=self.stoch_smatype)
            # - /ДОБАВЛЕНИЕ -
            stoch_k_val_5m = stoch_k_5m[-1] if len(stoch_k_5m) > 0 and not np.isnan(stoch_k_5m[-1]) else 50
            stoch_d_val_5m = stoch_d_5m[-1] if len(stoch_d_5m) > 0 and not np.isnan(stoch_d_5m[-1]) else 50
            
            # MACD (5m)
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            macd_5m, macdsignal_5m, macdhist_5m = talib.MACD(closes_5m,
                                                            fastperiod=self.macd_f,
                                                            slowperiod=self.macd_s,
                                                            signalperiod=self.macd_sig)
            # - /ДОБАВЛЕНИЕ -
            macd_val_5m = macdhist_5m[-1] if len(macdhist_5m) > 0 and not np.isnan(macdhist_5m[-1]) else 0
            
            # EMA (15m)
            closes_15m = np.array([x[4] for x in ohlcv_15m])
            if np.any(np.isnan(closes_15m)):
                self.logger.warning(f"NaN в данных OHLCV 15m для {symbol} в combo_strategy")
                return 0
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            ema_9_15m = talib.EMA(closes_15m, timeperiod=self.ema_short)
            ema_21_15m = talib.EMA(closes_15m, timeperiod=self.ema_long)
            # - /ДОБАВЛЕНИЕ -
            ema_9_val_15m = ema_9_15m[-1] if len(ema_9_15m) > 0 and not np.isnan(ema_9_15m[-1]) else 0
            ema_21_val_15m = ema_21_15m[-1] if len(ema_21_15m) > 0 and not np.isnan(ema_21_15m[-1]) else 0
            
            # Объемный импульс
            if len(volumes_5m) >= 5:
                avg_vol = np.mean(volumes_5m[-5:-1]) if len(volumes_5m) > 1 else 1
                current_vol = volumes_5m[-1]
                volume_impulse = current_vol / avg_vol if avg_vol > 0 else 1
            else:
                volume_impulse = 1
                
            # Взвешиваем сигналы
            rsi_signal = 0
            if rsi_val_5m < 30:
                rsi_signal = 1
            elif rsi_val_5m > 70:
                rsi_signal = -1
                
            stoch_signal = 0
            if stoch_k_val_5m < 20 and stoch_d_val_5m < 20:
                stoch_signal = 1
            elif stoch_k_val_5m > 80 and stoch_d_val_5m > 80:
                stoch_signal = -1
                
            macd_signal = 0
            if macd_val_5m > 0:
                macd_signal = 1
            elif macd_val_5m < 0:
                macd_signal = -1
                
            ema_signal = 0
            if ema_9_val_15m > ema_21_val_15m:
                ema_signal = 1
            elif ema_9_val_15m < ema_21_val_15m:
                ema_signal = -1
                
            volume_signal = 0
            if volume_impulse > 1.5:
                volume_signal = 0.5  # Умеренный вес
                
            # Финальный сигнал
            total_signal = (rsi_signal * 0.25 + stoch_signal * 0.25 + macd_signal * 0.25 + 
                          ema_signal * 0.15 + volume_signal * 0.1) * 100
                          
            return total_signal
            
        except Exception as e:
            self.logger.error(f"Ошибка combo стратегии для {symbol}: {e}")
            return 0

    async def open_position(self, symbol, signal_strength):
        """Открытие позиции"""
        try:
            # Проверяем максимальное количество позиций
            if len(self.positions) >= self.config['scalp']['max_positions']:
                self.logger.info(f"⚠️ {symbol}: Достигнут лимит позиций ({self.config['scalp']['max_positions']})")
                return
                
            # Проверяем, есть ли уже позиция по этой паре
            if symbol in self.positions:
                self.logger.info(f"⚠️ {symbol}: Позиция уже открыта")
                return
                
            # Получаем текущую цену
            ticker = await self.ex.fetch_ticker(symbol)
            current_price = ticker['last']
            
            # Проверяем минимальный лот
            if not await self.check_min_lot(symbol, 0.001, current_price):  # минимальная проверка
                self.logger.warning(f"⚠️ {symbol}: Не прошёл проверку минимального лота")
                return
                
            # Получаем выделенный капитал
            allocated_capital_for_symbol = self.allocated_capital.get(symbol, 0)
            if allocated_capital_for_symbol < self.config['scalp']['min_order_usd']:
                self.logger.info(f"⚠️ {symbol}: Недостаточный выделенный капитал ({allocated_capital_for_symbol:.2f} USDT)")
                return
                
            # Рассчитываем размер позиции
            position_size_usd = allocated_capital_for_symbol * self.config['scalp']['position_size_percent']
            amount_asset = position_size_usd / current_price
            
            # Проверка минимального лота
            if not await self.check_min_lot(symbol, amount_asset, current_price):
                return
                
            # Определяем сторону
            side = 'buy' if signal_strength > 0 else 'sell'
            
            # Создаем ордер
            if side == 'buy':
                order = await self.ex.create_market_buy_order(symbol, amount_asset)
            else:
                order = await self.ex.create_market_sell_order(symbol, amount_asset)
                
            order_id = order['id']
            
            # Сохраняем информацию о позиции
            self.positions[symbol] = {
                'side': 'long' if side == 'buy' else 'short',
                'amount': amount_asset,
                'entry': current_price,
                'timestamp': time.time()
            }
            
            self.logger.info(f"⚡ {symbol}: Открыта позиция {side.upper()} {amount_asset:.6f} @ {current_price:.2f}")
            
            # === v2.0: Добавлено логирование сделки ===
            trade_event = TradeEvent(
                ts=time.time(),
                symbol=symbol,
                side=side.upper(),
                price=current_price,
                qty=amount_asset
            )
            await self.log_trade(trade_event)
            # === /v2.0: Добавлено логирование сделки ===
            
        except ccxt.InsufficientFunds as e:
            self.logger.warning(f"⚠️ {symbol}: Недостаточно средств для открытия позиции: {e}")
        except Exception as e:
            self.logger.error(f"❌ Ошибка открытия позиции для {symbol}: {e}")

    async def close_position(self, symbol, reason="TP/SL"):
        """Закрытие позиции"""
        if symbol not in self.positions:
            return
            
        try:
            pos = self.positions[symbol]
            
            # Получаем актуальный баланс для закрытия
            balances = await self.get_balances()
            symbol_balance = balances.get(symbol, {'base': 0, 'quote': 0})
            base_asset = symbol.split('/')[0]
            current_amount = symbol_balance['base'] if base_asset else 0
            
            # Получаем текущую цену
            ticker = await self.ex.fetch_ticker(symbol)
            current_price = ticker['last']
            
            if pos['side'] == 'long' and current_amount > 0:
                self.logger.info(f"Закрытие длинной позиции {symbol}...")
                order = await self.ex.create_market_sell_order(symbol, current_amount)
                
                # === v2.0: Добавлено логирование сделки ===
                pnl = (current_price - pos['entry']) * current_amount
                trade_event = TradeEvent(
                    ts=time.time(),
                    symbol=symbol,
                    side='SELL',
                    price=current_price,
                    qty=current_amount,
                    pnl=pnl
                )
                await self.log_trade(trade_event)
                # === /v2.0: Добавлено логирование сделки ===
                
                self.logger.info(f"⚡ {symbol}: Закрыта позиция LONG {current_amount:.6f} @ {current_price:.2f} ({reason}) PnL: ${pnl:.2f}")
                
            elif pos['side'] == 'short':
                # Для шортов в spot нужно иметь базовый актив, что невозможно
                # Поэтому просто удаляем запись о позиции
                self.logger.info(f"⚡ {symbol}: Позиция SHORT закрыта (удалена запись) ({reason})")
                
            # Удаляем позицию из словаря
            del self.positions[symbol]
            
        except Exception as e:
            self.logger.error(f"❌ Ошибка закрытия позиции {symbol}: {e}")

    async def check_positions(self):
        """Проверка позиций на TP/SL и таймаут"""
        current_time = time.time()
        symbols_to_close = []
        
        for symbol, pos in self.positions.items():
            try:
                # Получаем текущую цену
                ticker = await self.ex.fetch_ticker(symbol)
                current_price = ticker['last']
                
                # Рассчитываем PnL
                if pos['side'] == 'long':
                    pnl_pct = (current_price - pos['entry']) / pos['entry'] * 100
                else:  # short
                    pnl_pct = (pos['entry'] - current_price) / pos['entry'] * 100
                    
                # Проверяем TP/SL
                tp_pct = self.tp_pct * 100
                sl_pct = self.sl_pct * 100
                
                if pnl_pct >= tp_pct:
                    symbols_to_close.append((symbol, "TP"))
                elif pnl_pct <= -sl_pct:
                    symbols_to_close.append((symbol, "SL"))
                # Проверяем таймаут
                elif current_time - pos['timestamp'] > self.max_hold_seconds:
                    symbols_to_close.append((symbol, "Timeout"))
                    
            except Exception as e:
                self.logger.error(f"❌ Ошибка проверки позиции {symbol}: {e}")
                
        # Закрываем позиции
        for symbol, reason in symbols_to_close:
            await self.close_position(symbol, reason)

    # v2.0: Добавлен метод закрытия всех позиций
    async def close_all_positions(self):
        """
        v2.0: Добавлен метод закрытия всех позиций.
        """
        self.logger.info("🚪 Начало закрытия всех позиций Scalp-бота...")
        
        symbols_to_close = list(self.positions.keys())
        for symbol in symbols_to_close:
            try:
                await self.close_position(symbol, "Shutdown")
            except Exception as e:
                self.logger.error(f"Ошибка закрытия позиции {symbol}: {e}")
                
        self.logger.info("✅ Закрытие всех позиций Scalp-бота завершено.")

    # v2.0: Переопределение метода graceful shutdown
    async def _shutdown(self):
        """
        v2.0: Переопределение graceful shutdown для закрытия позиций.
        """
        self.logger.info("🛑 Начало graceful shutdown Scalp-бота...")
        await self.close_all_positions()
        # Остановка IPC сервера
        if self.ipc_server:
            await self.ipc_server.stop()
        self.running = False
        self.logger.info("🛑 Graceful shutdown Scalp-бота завершен.")

    # - Метод execute_strategy для Scalp-бота -
    async def execute_strategy(self):
        """Реализация торговой стратегии для Scalp-бота"""
        # Проверяем позиции
        await self.check_positions()
        
        # Анализируем активы
        for symbol in self.symbols:
            try:
                # Проверяем тренд
                if not await self.trend_filter(symbol):
                    continue
                    
                # Проверяем спред
                if not await self.is_spread_acceptable(symbol):
                    self.logger.info(f"⚠️ {symbol}: Спред слишком большой")
                    continue
                    
                # Анализируем рынок
                signal_strength, indicators = await self.analyze_market_regime(symbol)
                
                # Проверяем силу сигнала
                threshold = self.config['scalp'].get('signal_threshold', 50)
                if abs(signal_strength) >= threshold:
                    self.logger.info(f"⚡ {symbol}: Сигнал {signal_strength:.1f} (порог {threshold})")
                    await self.open_position(symbol, signal_strength)
                else:
                    self.logger.debug(f"🔍 {symbol}: Сигнал {signal_strength:.1f} < порога {threshold}")
                    
            except Exception as e:
                self.logger.error(f"❌ Ошибка анализа {symbol}: {e}")
    # - /Метод execute_strategy для Scalp-бота -

    async def run(self):
        """Основной цикл работы бота"""
        try:
            await self.ex.load_markets()
            await self.update_capital()
            
            # Инициализация капитала
            self.working_capital = self.total_capital * 0.5
            self.reserve_capital = self.total_capital * 0.5
            self.logger.info(f"💰 Инициализация капитала: Всего=${self.total_capital:.2f}, Рабочий=${self.working_capital:.2f}, Резерв=${self.reserve_capital:.2f}")
            
            # v2.0: Переопределение метода распределения капитала
            await self.distribute_capital()
            
            self.logger.info(f"🟢 Scalp Bot запущен. Начальный капитал: {self.total_capital:.2f} USDT")
            await self.send(f"🟢 Scalp Bot запущен. Капитал: {self.total_capital:.2f} USDT")
            
            # Основной цикл
            while self.running:
                try:
                    await self.update_capital()
                    
                    # Периодическое перераспределение капитала
                    current_time = time.time()
                    if current_time - self.last_redistribution > self.redistribution_interval:
                        await self.distribute_capital()
                        self.last_redistribution = current_time
                    
                    # Специфичная логика бота
                    await self.execute_strategy()
                    
                    # Пауза
                    sleep_interval = self.config['scalp']['sleep_interval']
                    await asyncio.sleep(sleep_interval)
                    
                except ccxt.NetworkError as e:
                    self.logger.error(f"Сетевая ошибка: {e}")
                    await asyncio.sleep(10)
                except ccxt.ExchangeError as e:
                    self.logger.error(f"Биржевая ошибка: {e}")
                    await asyncio.sleep(sleep_interval * 2)
                except Exception as e:
                    self.logger.error(f"❌ Критическая ошибка в основном цикле Scalp: {e}")
                    await asyncio.sleep(sleep_interval * 3)
                    
        except Exception as e:
            self.logger.error(f"Критическая ошибка: {e}")
        finally:
            await self._shutdown()

    def exit_gracefully(self, signum, frame):
        """Обработчик сигналов для graceful shutdown"""
        self.logger.info(f"🛑 Scalp graceful shutdown (сигнал {signum})")
        self.running = False

    # v2.0: Переопределение метода распределения капитала
    async def distribute_capital(self):
        """
        Переопределяем метод из базового класса для Scalp-бота.
        v2.0: Использует CapitalDistributor для корректного распределения.
        """
        self.logger.info("🔄 Начало перераспределения капитала для Scalp...")
        
        # v2.0: Используем новый модуль распределения капитала
        distributor = CapitalDistributor(self.ex)
        allocations = await distributor.distribute_for_strategy('scalp', self.symbols)
        
        self.allocated_capital = allocations
        
        # Логирование распределения
        for symbol, amount in self.allocated_capital.items():
            self.logger.info(f"💰 {symbol}: выделено ${amount:.2f} USDT")
            
        self.logger.info("✅ Перераспределение капитала для Scalp завершено.")

    # - ДОБАВЛЕНИЕ 1: Метод логирования сделок -
    async def log_trade(self, event: TradeEvent):
        """Логирование сделки"""
        msg = (f"{event.symbol} <b>{'ОТКРЫТИЕ' if event.pnl == 0 else 'ЗАКРЫТИЕ'}</b>\n"
               f"💰 Цена: <code>{event.price:.4f}</code>\n"
               f"📦 Объём: <code>{event.qty:.4f}</code>")
        if event.pnl != 0:
            msg += f"\n📊 PnL: <code>{event.pnl:.2f}</code> $"
        self.logger.info(msg.replace('<b>', '').replace('</code>', ''))
        await self.send(msg)
    # - /ДОБАВЛЕНИЕ 1 -

# - Точка входа -
async def main():
    bot = MultiAssetScalpBot()
    
    # Запуск IPC сервера
    if bot.ipc_server:
        await bot.ipc_server.start()
        
    await bot.run()

if __name__ == "__main__":
    if not os.path.exists('.env'):
        print("❌ Файл .env не найден!")
        print("Создайте файл .env с вашими API ключами")
        sys.exit(1)
        
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("🛑 Бот остановлен пользователем")
    except Exception as e:
        print(f"❌ Критическая ошибка: {e}")
        logging.error(f"Критическая ошибка: {e}")
# - /Точка входа -


# v2.0 (+правки из анализа: futures режим, spot sell, CCI порог, cooldown, закрытие позиций, исправления)
"""
Multi-Asset Grid Trading Bot.
v2.0: Добавлен режим futures, исправлены Sell-уровни, добавлены cooldown и CCI-порог, исправлено закрытие позиций.
"""
import ccxt.async_support as ccxt
import numpy as np
import talib
import asyncio
import time
import logging
import signal
import sys
import os
import json
import math
import collections
from datetime import datetime, timedelta
from telegram import Bot
from dotenv import load_dotenv
# - ДОБАВЛЕНИЕ 1: Импорт log_helper -
from log_helper import build_logger
# - /ДОБАВЛЕНИЕ 1 -
# - ДОБАВЛЕНИЕ 2: Импорт ConfigManager -
from config_manager import ConfigManager
# - /ДОБАВЛЕНИЕ 2 -
# - ДОБАВЛЕНИЕ 3: Импорт IPC сервера -
from ipc import GridBotIPCServer
# - /ДОБАВЛЕНИЕ 3 -
# - ДОБАВЛЕНИЕ 4: Импорт dataclasses для TradeEvent -
from dataclasses import dataclass, field
# - /ДОБАВЛЕНИЕ 4 -
# v2.0: Импорт нового модуля распределения капитала
from capital_distributor import CapitalDistributor

load_dotenv()
os.makedirs('logs', exist_ok=True)

# === v2.0: Исправления и дополнения из чек-листа ===
# - Добавлен режим futures
# - Исправлен Sell-уровни для spot
# - Добавлен CCI порог из конфига
# - Добавлен cooldown
# - Исправлены ошибки обработки рынка
# - Добавлен graceful shutdown с закрытием позиций
# - Исправлена утечка памяти в executed_order_ids
# === /v2.0 ===

logger = logging.getLogger(__name__)

# - ДОБАВЛЕНИЕ 4: Определение TradeEvent -
@dataclass
class TradeEvent:
    ts: float
    symbol: str
    side: str  # buy/sell
    price: float
    qty: float
    pnl: float = 0.0
# - /ДОБАВЛЕНИЕ 4 -

class MultiAssetGridBot:
    """
    Multi-Asset Grid Trading Bot.
    v2.0: Добавлен режим futures, исправлены Sell-уровни, добавлены cooldown и CCI-порог, исправлено закрытие позиций.
    """

    def __init__(self):
        # - ДОБАВЛЕНИЕ 1: Используем log_helper для персонального лог-файла -
        self.logger = build_logger("grid_bot")
        # - /ДОБАВЛЕНИЕ 1 -
        
        # - ДОБАВЛЕНИЕ 2: Загрузка конфигурации через ConfigManager -
        self.config_manager = ConfigManager()
        self.config = self.config_manager.get_config()
        # - /ДОБАВЛЕНИЕ 2 -
        
        # Инициализация биржи
        API_KEY = os.getenv('API_KEY')
        API_SECRET = os.getenv('API_SECRET')
        PASSPHRASE = os.getenv('PASSPHRASE')
        if not all([API_KEY, API_SECRET, PASSPHRASE]):
            raise ValueError("❌ Отсутствуют обязательные переменные окружения: API_KEY, API_SECRET, PASSPHRASE")
            
        self.ex = ccxt.okx({
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'password': PASSPHRASE,
            'sandbox': True,  # Используем демо-режим
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        
        self.symbols = self.config['symbols']
        self.chat_ids = self.config['chat_ids']
        self.tg_bot = Bot(token=os.getenv('TELEGRAM_BOT_TOKEN'))
        self.running = True
        self.last_notification = 0
        
        # Состояние капитала
        self.total_capital = 0
        self.working_capital = 0
        self.reserve_capital = 0
        self.allocated_capital = {}  # {symbol: float}
        self.last_redistribution = 0
        self.redistribution_interval = self.config.get('redistribution_interval', 1800)  # 30 минут
        self.last_full_equity = 0
        self.equity_history = collections.deque(maxlen=200)
        
        # - ДОБАВЛЕНИЕ 6: Буфер для сделок за 24 часа -
        self.trades_24h: list[TradeEvent] = []
        # - /ДОБАВЛЕНИЕ 6 -
        
        # Состояние Grid-бота
        self.asset_grids = {}  # {symbol: {order_id: order_info}}
        # v2.0: Исправление 2 - Используем deque с maxlen для предотвращения утечки памяти
        self.executed_order_ids = collections.deque(maxlen=1000)  # Исправление 2
        # v2.0: Добавлен словарь для cooldown
        self.last_grid_updates = {}
        
        # - ДОБАВЛЕНИЕ 7: Отправка уведомления о старте -
        # asyncio.create_task(self._send_start_notification()) # Вызывается в run()
        # - /ДОБАВЛЕНИЕ 7 -
        
        # Установка обработчиков сигналов
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        # - ДОБАВЛЕНИЕ 3: Инициализация IPC сервера -
        self.ipc_server = GridBotIPCServer(self) if self.config.get('ipc_enabled', True) else None
        # - /ДОБАВЛЕНИЕ 3 -
        
        # - ДОБАВЛЕНИЕ 5: Параметры для TP ордеров -
        self.tp_multiplier = 1.0  # Множитель для TP, можно сделать настраиваемым
        # - /ДОБАВЛЕНИЕ 5 -
        
        # - ДОБАВЛЕНИЕ 10: Параметры из конфига -
        cfg = self.config['grid']['indicators']
        self.rsi_period = cfg['rsi']['timeperiod']
        self.stoch_fk = cfg['stoch']['fastk_period']
        self.stoch_sk = cfg['stoch']['slowk_period']
        self.stoch_smatype = cfg['stoch']['slowk_matype']
        self.stoch_sd = cfg['stoch']['slowd_period']
        self.stoch_smatype = cfg['stoch']['slowd_matype']
        self.macd_f = cfg['macd']['fastperiod']
        self.macd_s = cfg['macd']['slowperiod']
        self.macd_sig = cfg['macd']['signalperiod']
        self.ema_short = cfg['ema']['short_period']
        self.ema_long = cfg['ema']['long_period']
        self.atr_period = cfg['atr']['timeperiod']
        self.bb_period = cfg['bb']['timeperiod']
        self.bb_nbdevup = cfg['bb']['nbdevup']
        self.bb_nbdevdn = cfg['bb']['nbdevdn']
        # - /ДОБАВЛЕНИЕ 10 -
        
        # v2.0: Добавлены параметры из конфига
        self.cci_block = self.config['grid'].get('cci_block', -100)
        self.grid_mode = self.config['grid'].get('grid_mode', 'spot')

    # - ДОБАВЛЕНИЕ 8: Метод отправки HTML сообщений -
    async def _send_html(self, text: str):
        """Отправка HTML-сообщения в Telegram"""
        now = time.time()
        if now - self.last_notification < 2:
            await asyncio.sleep(2 - (now - self.last_notification))
        self.last_notification = now
        for cid in self.chat_ids:
            try:
                await self.tg_bot.send_message(chat_id=cid, text=text, parse_mode='HTML')
            except Exception as e:
                self.logger.error(f"Telegram error: {e}")
    # - /ДОБАВЛЕНИЕ 8 -
    
    # - ДОБАВЛЕНИЕ 9: Метод отправки уведомления о старте -
    async def _send_start_notification(self):
        """Отправка уведомления о старте бота"""
        await asyncio.sleep(1)  # Небольшая задержка для инициализации
        await self.update_capital()
        msg = (f"🚀 <b>GRID BOT СТАРТ</b>\n"
               f"📊 Капитал: <code>{self.total_capital:.2f}</code> USDT\n"
               f"🔧 Пары: {', '.join(self.symbols)}")
        self.logger.info(msg.replace('<b>', '').replace('</b>', '').replace('<code>', '').replace('</code>', ''))
        await self._send_html(msg)
    # - /ДОБАВЛЕНИЕ 9 -
    
    async def send(self, msg):
        """Отправка сообщения в Telegram"""
        now = time.time()
        if now - self.last_notification < 2:
            await asyncio.sleep(2 - (now - self.last_notification))
        self.last_notification = now
        for cid in self.chat_ids:
            try:
                await self.tg_bot.send_message(chat_id=cid, text=msg)
            except Exception as e:
                self.logger.error(f"Ошибка отправки в Telegram: {e}")

    # - ИСПРАВЛЕНИЕ: Корректный метод получения балансов -
    async def get_balances(self):
        """Получение балансов для всех символов"""
        try:
            # - ИСПРАВЛЕНИЕ 1: Получаем баланс ОДИН РАЗ -
            bal = await self.ex.fetch_balance({'type': 'spot'})
            # - /ИСПРАВЛЕНИЕ 1 -
            balances = {}
            for symbol in self.symbols:
                base_currency = symbol.split('/')[0]
                quote_currency = symbol.split('/')[1]
                base_free = bal['free'].get(base_currency, 0)
                base_total = bal['total'].get(base_currency, 0)
                quote_free = bal['free'].get(quote_currency, 0)
                quote_total = bal['total'].get(quote_currency, 0)
                balances[symbol] = {
                    'base': base_total,
                    'quote': quote_total,
                    'free_base': base_free,
                    'free_quote': quote_free
                }
            return balances
        except Exception as e:
            self.logger.error(f"Ошибка получения балансов: {e}")
            return {}
    # - /ИСПРАВЛЕНИЕ -

    async def update_capital(self):
        """Обновление информации о капитале"""
        try:
            balances = await self.get_balances()
            self.total_capital = 0
            for symbol in self.symbols:
                symbol_balance = balances.get(symbol, {'base': 0, 'quote': 0})
                try:
                    ticker = await self.ex.fetch_ticker(symbol)
                    price = ticker['last']
                    # Рассчитываем эквити для символа
                    base_equity = symbol_balance['base'] * price
                    quote_equity = symbol_balance['quote']
                    equity = base_equity + quote_equity
                    self.total_capital += equity
                    # - ИСПРАВЛЕНИЕ 2: Исправлена ошибка форматирования -
                    self.logger.debug(f"💰 {symbol}: {symbol_balance['base']:.6f} {symbol.split('/')[0]} + {symbol_balance['quote']:.2f} {symbol.split('/')[1]} ≈ {equity:.2f} USDT")
                    # - /ИСПРАВЛЕНИЕ 2 -
                except Exception as e:
                    self.logger.warning(f"Не удалось получить цену для {symbol} при обновлении капитала: {e}")
            
            self.last_full_equity = self.total_capital
            self.logger.info(f"💰 Обновлен капитал: Всего=${self.total_capital:.2f} USDT")
        except Exception as e:
            self.logger.error(f"❌ Критическая ошибка обновления капитала: {e}")
    # - /ИСПРАВЛЕНИЕ -

    # - ИСПРАВЛЕНИЕ 1: Защита метода check_min_lot от NoneType -
    async def check_min_lot(self, symbol, amount, price):
        """
        Проверка соответствия минимальным требованиям биржи с защитой от None.
        """
        try:
            # 1. Получаем информацию о рынке
            market_info = self.ex.market(symbol)
            
            # === v2.0: Исправление 1 - Добавлена защита от None ===
            if not market_info:
                self.logger.warning(f"⚠️ {symbol}: Не удалось получить информацию о рынке")
                return False
            # === /v2.0: Исправление 1 ===
            
            # 2. Получаем минимальные значения из конфигурации рынка
            min_amount = market_info.get('limits', {}).get('amount', {}).get('min', 0)
            min_cost = market_info.get('limits', {}).get('cost', {}).get('min', 0)
            
            # 3. Проверяем минимальный объем
            if amount < min_amount:
                self.logger.info(f"⚠️ {symbol}: Объем {amount} < минимального {min_amount}")
                return False
                
            # 4. Проверяем минимальную стоимость
            cost = amount * price
            if cost < min_cost:
                self.logger.info(f"⚠️ {symbol}: Стоимость {cost:.4f} < минимальной {min_cost}")
                return False
                
            return True
        except Exception as e:
            self.logger.error(f"Ошибка проверки минимального лота для {symbol}: {e}")
            return False # В случае ошибки считаем проверку не пройденной
    # - /ИСПРАВЛЕНИЕ 1 -

    async def analyze_market_regime(self, symbol, ohlcv):
        """Анализ рыночного режима для адаптивной сетки"""
        try:
            if len(ohlcv) < 20:
                self.logger.warning(f"Недостаточно данных OHLCV для {symbol} в analyze_market_regime")
                return 'neutral', 1.0, 0.01, 0.001, 0, 50, 0  # значения по умолчанию
                
            closes = np.array([candle[4] for candle in ohlcv])
            highs = np.array([candle[2] for candle in ohlcv])
            lows = np.array([candle[3] for candle in ohlcv])
            
            # Проверка на NaN
            if np.any(np.isnan(closes)) or np.any(np.isnan(highs)) or np.any(np.isnan(lows)):
                self.logger.warning(f"NaN в данных OHLCV для {symbol} в analyze_market_regime")
                return 'neutral', 1.0, 0.01, 0.001, 0, 50, 0
                
            # Расчет волатильности (ATR)
            # - ДОБАВЛЕНИЕ: Используем параметр из конфига -
            atr = talib.ATR(highs, lows, closes, timeperiod=self.atr_period)
            # - /ДОБАВЛЕНИЕ -
            atr_value = atr[-1] if len(atr) > 0 and not np.isnan(atr[-1]) else 0.001 * closes[-1] if len(closes) > 0 else 0.001
            avg_price = np.mean(closes)
            volatility = (atr_value / avg_price) if avg_price > 0 else 0
            
            # Сила тренда (ADX)
            adx = talib.ADX(highs, lows, closes, timeperiod=14)
            adx_value = adx[-1] if len(adx) > 0 and not np.isnan(adx[-1]) else 20
            
            # RSI
            # - ДОБАВЛЕНИЕ: Используем параметр из конфига -
            rsi = talib.RSI(closes, timeperiod=self.rsi_period)
            # - /ДОБАВЛЕНИЕ -
            rsi_value = rsi[-1] if len(rsi) > 0 and not np.isnan(rsi[-1]) else 50
            
            # Bollinger Bands Width
            # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            bb_upper, bb_middle, bb_lower = talib.BBANDS(closes, timeperiod=self.bb_period,
                                                        nbdevup=self.bb_nbdevup, nbdevdn=self.bb_nbdevdn)
            # - /ДОБАВЛЕНИЕ -
            if len(bb_upper) > 0 and len(bb_lower) > 0 and len(bb_middle) > 0 and \
               not np.isnan(bb_upper[-1]) and not np.isnan(bb_lower[-1]) and not np.isnan(bb_middle[-1]) and \
               (bb_upper[-1] - bb_lower[-1]) > 0:
                bb_width = (bb_upper[-1] - bb_lower[-1]) / bb_middle[-1]
            else:
                bb_width = 0.02
                
            # CCI
            cci = talib.CCI(highs, lows, closes, timeperiod=14)
            cci_value = cci[-1] if len(cci) > 0 and not np.isnan(cci[-1]) else 0
            
            # Тренд на 15m
            trend_strength = 0
            # if len(ohlcv_15m) >= 20:
            #     closes_15m = np.array([x[4] for x in ohlcv_15m])
            #     if not np.any(np.isnan(closes_15m)):
            #         # - ДОБАВЛЕНИЕ: Используем параметры из конфига -
            #         ema_9 = talib.EMA(closes_15m, timeperiod=self.ema_short)
            #         ema_21 = talib.EMA(closes_15m, timeperiod=self.ema_long)
            #         # - /ДОБАВЛЕНИЕ -
            #         ema_9_val = ema_9[-1] if len(ema_9) > 0 and not np.isnan(ema_9[-1]) else 0
            #         ema_21_val = ema_21[-1] if len(ema_21) > 0 and not np.isnan(ema_21[-1]) else 0
            #         if ema_21_val > 0:
            #             trend_strength = (ema_9_val - ema_21_val) / ema_21_val
                        
            # Определение режима
            if adx_value > 25 and abs(rsi_value - 50) > 20:
                mode = 'trend'
            elif adx_value < 20 and abs(rsi_value - 50) < 15:
                mode = 'range'
            elif volatility > 0.02:  # 2% волатильность
                mode = 'volatile'
            else:
                mode = 'neutral'
                
            # Адаптивные параметры
            spacing_mult = 1.0 + volatility * 10
            grid_levels = max(4, min(8, int(6 / (1 + volatility * 10))))
            
            # Сила тренда (нормализованная 0-1)
            trend_strength = adx_value / 100 if adx_value > 0 else 0
            
            return mode, spacing_mult, grid_levels, volatility, trend_strength, rsi_value, cci_value
        except Exception as e:
            self.logger.error(f"Ошибка анализа рынка для {symbol}: {e}")
            # Возвращаем значения по умолчанию в случае ошибки
            return 'neutral', 1.0, 6, 0.01, 0, 50, 0

    async def is_spread_acceptable(self, symbol):
        """Фильтр по спреду"""
        try:
            ticker = await self.ex.fetch_ticker(symbol)
            bid = ticker['bid']
            ask = ticker['ask']
            if bid is None or ask is None:
                return False
            spread_pct = (ask - bid) / bid
            # Спред должен быть меньше 0.1%
            return spread_pct < 0.001
        except Exception as e:
            self.logger.error(f"Ошибка проверки спреда для {symbol}: {e}")
            return False

    async def create_reverse_grid(self, symbol):
        """Создание реверсивной сетки (основной метод)"""
        # === v2.0: Добавлен cooldown ===
        current_time = time.time()
        last_update = self.last_grid_updates.get(symbol, 0)
        cooldown_period = 60  # 1 минута
        
        if current_time - last_update < cooldown_period:
            self.logger.debug(f"⏳ {symbol}: Пропущено обновление из-за cooldown")
            return
            
        self.last_grid_updates[symbol] = current_time
        # === /v2.0: Добавлен cooldown ===
        
        try:
            # 1. Проверка фильтров
            if not await self.is_spread_acceptable(symbol):
                self.logger.info(f"⚠️ {symbol}: Создание сетки заблокировано фильтром по спреду.")
                return
                
            # Получение данных
            balances = await self.get_balances()
            symbol_balance = balances.get(symbol, {'base': 0, 'quote': 0})
            ticker = await self.ex.fetch_ticker(symbol)
            current_price = ticker['last']
            allocated_capital_for_symbol = self.allocated_capital.get(symbol, 0)
            
            # - ИСПРАВЛЕНИЕ 1: Используем asset_equity_raw -
            base_equity = symbol_balance['base'] * current_price
            quote_equity = symbol_balance['quote']
            asset_equity_raw = base_equity + quote_equity
            # - /ИСПРАВЛЕНИЕ 1 -
            
            # 2. Проверка минимального капитала
            if allocated_capital_for_symbol < self.config['grid']['min_order_usd'] * 2:
                self.logger.info(f"⚠️ {symbol}: Недостаточный выделенный капитал для создания сетки ({allocated_capital_for_symbol:.2f} USDT)")
                return
                
            # 3. Анализ рынка
            ohlcv = await self.ex.fetch_ohlcv(symbol, '1m', limit=50)
            mode, spacing_mult, grid_levels, volatility, trend_strength, rsi, cci = await self.analyze_market_regime(symbol, ohlcv)
            
            # === v2.0: Добавлен CCI-порог из конфига ===
            if cci < self.cci_block:
                self.logger.info(f"⚠️ {symbol}: Создание сетки заблокировано CCI фильтром (CCI={cci:.2f} < {self.cci_block})")
                return
            # === /v2.0: Добавлен CCI-порог ===
                
            # 4. Параметры сетки
            base_spacing = self.config['grid']['base_spacing']
            adjusted_spacing = base_spacing * spacing_mult
            max_levels = self.config['grid']['max_levels']
            actual_levels = min(grid_levels, max_levels)
            
            # 5. Рассчитываем объем на уровень
            total_orders = actual_levels * 2  # BUY и SELL уровни
            capital_per_order = allocated_capital_for_symbol / total_orders if total_orders > 0 else 0
            
            if capital_per_order <= 0:
                self.logger.warning(f"⚠️ {symbol}: Невозможно рассчитать объем ордера")
                return
                
            # === v2.0: Добавлен режим futures ===
            if self.grid_mode == 'futures':
                # Установка режима позиций для фьючерсов
                try:
                    await self.ex.set_position_mode(hedged=True)  # OKX specific
                    self.logger.info(f"🎛️ {symbol}: Установлен режим позиций hedged для futures")
                except Exception as e:
                    self.logger.warning(f"⚠️ {symbol}: Не удалось установить режим позиций futures: {e}")
            # === /v2.0: Добавлен режим futures ===
            
            # 6. Создаем BUY уровни (LONG)
            buy_prices = []
            for i in range(actual_levels):
                price_level = current_price * (1 - adjusted_spacing * (i + 1))
                buy_prices.append(price_level)
                
            # 7. Создаем SELL уровни
            sell_prices = []
            # === v2.0: Исправлен Sell-уровни для spot ===
            if self.grid_mode == 'spot':
                # Для spot проверяем наличие базового актива
                balance = await self.get_balances()
                base_asset = symbol.split('/')[0]
                base_balance = balance.get(symbol, {}).get('base', 0) # Используем общий баланс
                
                if base_balance <= 0:
                    self.logger.warning(f"⚠️ {symbol}: Нет базового актива для создания SELL ордеров в spot режиме на старте. Создаем сетку только BUY.")
                else:
                    # Рассчитываем количество для продажи на каждый уровень
                    amount_per_sell_level = base_balance / actual_levels if actual_levels > 0 else 0
                    if amount_per_sell_level > 0:
                        for i in range(actual_levels):
                            price_level = current_price * (1 + adjusted_spacing * (i + 1))
                            sell_prices.append(price_level)
            else:
                # Для futures создаем SELL уровни как обычно
                for i in range(actual_levels):
                    price_level = current_price * (1 + adjusted_spacing * (i + 1))
                    sell_prices.append(price_level)
            # === /v2.0: Исправлен Sell-уровни ===
            
            # 8. Отменяем существующие ордера по этой паре
            if symbol in self.asset_grids:
                existing_orders = list(self.asset_grids[symbol].items())
                cancel_tasks = []
                for order_id, order_info in existing_orders:
                    try:
                        # Используем метод cancel_order напрямую
                        cancel_task = asyncio.create_task(self.ex.cancel_order(order_id, symbol))
                        cancel_tasks.append(cancel_task)
                        self.logger.info(f"❌ {symbol}: Отменён ордер #{order_id}")
                        del self.asset_grids[symbol][order_id]
                    except ccxt.OrderNotFound:
                        # Ордер уже отменен или исполнен
                        if order_id in self.asset_grids[symbol]:
                            del self.asset_grids[symbol][order_id]
                        self.logger.debug(f"Ордер {order_id} для {symbol} не найден при отмене (возможно, уже исполнен)")
                    except Exception as e:
                        self.logger.error(f"Ошибка отмены ордера {order_id} для {symbol}: {e}")
                        
                # if cancel_tasks:
                #     results = await asyncio.gather(*cancel_tasks, return_exceptions=True)
                #     successful_cancels = sum(1 for r in results if not isinstance(r, Exception))
                #     self.logger.info(f"✅ Отменено {successful_cancels} ордеров для {symbol}")
                        
            # 9. Создаем новые ордера
            new_orders = {}
            
            # BUY ордера
            for i, buy_price in enumerate(buy_prices):
                try:
                    amount_usd = capital_per_order
                    amount_asset = amount_usd / buy_price
                    
                    # Проверка минимального лота
                    if not await self.check_min_lot(symbol, amount_asset, buy_price):
                        continue
                        
                    order = await self.ex.create_limit_buy_order(symbol, amount_asset, buy_price)
                    order_id = order['id']
                    
                    new_orders[order_id] = {
                        'type': 'buy',
                        'price': buy_price,
                        'amount': amount_asset,
                        'level': i+1,
                        'mode': mode
                    }
                    
                    self.logger.info(f"📉 {symbol} BUY ордер #{order_id}: {amount_asset:.6f} @ {buy_price:.2f} (${amount_usd:.2f})")
                except ccxt.InsufficientFunds as e:
                    self.logger.warning(f"⚠️ {symbol} Недостаточно средств для BUY ордера на уровне {i+1}: {e}")
                    break
                except Exception as e:
                    self.logger.error(f"❌ Ошибка BUY ордера {symbol} на уровне {i+1}: {e}")
                    
            # SELL ордера
            for i, sell_price in enumerate(sell_prices):
                try:
                    if self.grid_mode == 'spot':
                        # Для spot используем базовый баланс
                        balance = await self.get_balances()
                        symbol_balance = balance.get(symbol, {'base': 0, 'quote': 0})
                        base_balance = symbol_balance['base']
                        amount_per_sell_level = base_balance / len(sell_prices) if len(sell_prices) > 0 else 0
                        
                        if amount_per_sell_level <= 0:
                            continue
                            
                        # Проверка минимального лота
                        if not await self.check_min_lot(symbol, amount_per_sell_level, sell_price):
                            continue
                            
                        order = await self.ex.create_limit_sell_order(symbol, amount_per_sell_level, sell_price)
                    else:
                        # Для futures рассчитываем количество как для LONG позиции
                        amount_usd = capital_per_order
                        amount_asset = amount_usd / sell_price
                        
                        # Проверка минимального лота
                        if not await self.check_min_lot(symbol, amount_asset, sell_price):
                            continue
                            
                        order = await self.ex.create_limit_sell_order(symbol, amount_asset, sell_price)
                        
                    order_id = order['id']
                    
                    new_orders[order_id] = {
                        'type': 'sell',
                        'price': sell_price,
                        'amount': amount_per_sell_level if self.grid_mode == 'spot' else amount_asset,
                        'level': i+1,
                        'mode': mode
                    }
                    
                    self.logger.info(f"📈 {symbol} SELL ордер #{order_id}: {new_orders[order_id]['amount']:.6f} @ {sell_price:.2f}")
                except ccxt.InsufficientFunds as e:
                    self.logger.warning(f"⚠️ {symbol} Недостаточно средств для SELL ордера на уровне {i+1}: {e}")
                    break
                except Exception as e:
                    self.logger.error(f"❌ Ошибка SELL ордера {symbol} на уровне {i+1}: {e}")
                    
            # Сохраняем информацию о новых ордерах
            self.asset_grids[symbol] = new_orders
            self.logger.info(f"🔧 {symbol} Grid: Buy {len(buy_prices)} | Sell {len(sell_prices)}")
            
        except Exception as e:
            self.logger.error(f"❌ Критическая ошибка создания сетки для {symbol}: {e}")

    async def check_all_orders(self):
        """Проверка исполнения всех ордеров"""
        for symbol in list(self.asset_grids.keys()):
            try:
                open_orders = await self.ex.fetch_open_orders(symbol)
                open_order_ids = {order['id'] for order in open_orders}
            except Exception as e:
                self.logger.error(f"Ошибка получения ордеров для {symbol}: {e}")
                continue
                
            executed_orders = []
            # Используем список для итерации, чтобы избежать изменения словаря во время итерации
            current_grid_orders = list(self.asset_grids[symbol].items())
            
            for order_id, order_info in current_grid_orders:
                if order_id not in open_order_ids and order_id not in self.executed_order_ids:
                    # Ордер исполнен
                    executed_orders.append((order_id, order_info))
                    self.executed_order_ids.append(order_id)
                    self.logger.info(f"✅ {symbol}: Исполнен ордер #{order_id} ({order_info['type']})")
                    
            # Обработка исполненных ордеров
            for order_id, order_info in executed_orders:
                # Удаляем из активных ордеров
                if order_id in self.asset_grids[symbol]:
                    del self.asset_grids[symbol][order_id]
                    
                # - ДОБАВЛЕНИЕ 1: Логирование исполнения ордера -
                trade_event = TradeEvent(
                    ts=time.time(),
                    symbol=symbol,
                    side=order_info['type'],
                    price=order_info['price'],
                    qty=order_info['amount']
                )
                # await self.log_trade(trade_event) # Уже логируется ниже при создании встречного ордера
                # - /ДОБАВЛЕНИЕ 1 -
                
                # Создаем встречный ордер
                try:
                    if order_info['type'] == 'buy':
                        # Создаем SELL ордер (Take Profit)
                        tp_price = order_info['price'] * (1 + self.config['grid']['base_spacing'])
                        tp_amount = order_info['amount']
                        
                        # Проверка минимального лота
                        if await self.check_min_lot(symbol, tp_amount, tp_price):
                            tp_order = await self.ex.create_limit_sell_order(symbol, tp_amount, tp_price)
                            tp_order_id = tp_order['id']
                            
                            self.asset_grids[symbol][tp_order_id] = {
                                'type': 'sell',
                                'price': tp_price,
                                'amount': tp_amount,
                                'level': order_info['level'],
                                'mode': order_info['mode']
                            }
                            
                            # - ДОБАВЛЕНИЕ 5: Логирование создания TP SELL ордера -
                            self.logger.info(f"🎯 {symbol} TP SELL ордер #{tp_order_id}: {tp_amount:.6f} @ {tp_price:.2f}")
                            # - /ДОБАВЛЕНИЕ 5 -
                            
                    elif order_info['type'] == 'sell':
                        # Создаем BUY ордер (Take Profit)
                        tp_price = order_info['price'] * (1 - self.config['grid']['base_spacing'])
                        tp_amount = order_info['amount']
                        
                        # Проверка минимального лота
                        if await self.check_min_lot(symbol, tp_amount, tp_price):
                            # Рассчитываем стоимость в USDT
                            tp_amount_usd = tp_amount * tp_price
                            
                            tp_order = await self.ex.create_limit_buy_order(symbol, tp_amount, tp_price)
                            tp_order_id = tp_order['id']
                            
                            self.asset_grids[symbol][tp_order_id] = {
                                'type': 'buy',
                                'price': tp_price,
                                'amount': tp_amount,
                                'level': order_info['level'],
                                'mode': order_info['mode']
                            }
                            
                            # - ДОБАВЛЕНИЕ 5: Логирование создания TP BUY ордера -
                            self.logger.info(f"🎯 {symbol} TP BUY ордер #{tp_order_id}: {tp_amount:.6f} @ {tp_price:.2f} (${tp_amount_usd:.2f})")
                            # - /ДОБАВЛЕНИЕ 5 -
                            
                except Exception as e:
                    self.logger.error(f"❌ Ошибка создания встречного ордера для {symbol}: {e}")

    # v2.0: Добавлен метод закрытия всех позиций
    async def close_all_positions(self):
        """
        v2.0: Добавлен метод закрытия всех позиций и отмены ордеров.
        """
        self.logger.info("🚪 Начало закрытия всех позиций Grid-бота...")
        
        # Отмена всех открытых ордеров
        for symbol in list(self.asset_grids.keys()):
            existing_orders = list(self.asset_grids[symbol].items())
            for order_id, order_info in existing_orders:
                try:
                    await self.ex.cancel_order(order_id, symbol)
                    self.logger.info(f"❌ {symbol}: Отменён ордер #{order_id} при закрытии")
                except Exception as e:
                    self.logger.error(f"Ошибка отмены ордера {order_id} для {symbol}: {e}")
        
        # Закрытие позиций (для futures)
        if self.grid_mode == 'futures':
            try:
                positions = await self.ex.fetch_positions()
                for position in positions:
                    symbol = position['symbol']
                    side = position['side']
                    amount = position['contracts']
                    
                    if amount > 0:
                        close_side = 'sell' if side == 'long' else 'buy'
                        try:
                            # Создаем рыночный ордер для закрытия позиции
                            if close_side == 'sell':
                                await self.ex.create_market_sell_order(symbol, amount)
                            else:
                                await self.ex.create_market_buy_order(symbol, amount)
                            self.logger.info(f"🚪 {symbol}: Закрыта позиция {side} {amount}")
                        except Exception as e:
                            self.logger.error(f"Ошибка закрытия позиции {symbol} {side}: {e}")
            except Exception as e:
                self.logger.error(f"Ошибка получения позиций для закрытия: {e}")
        else:
            # Для spot режима просто отменяем ордера, позиций как таковых нет
            # Но если у нас есть открытые лонги (BUY ордера исполнились), мы могли бы их закрыть рыночно
            # Однако, оригинальная логика не предполагает этого. Просто отменяем ордера.
            self.logger.info("📭 Spot режим: ордера отменены, открытых позиций нет (или закрываются рыночными ордерами при исполнении сетки)")
            
        self.logger.info("✅ Закрытие всех позиций Grid-бота завершено.")

    # - Метод execute_strategy для Grid-бота -
    async def execute_strategy(self):
        """Реализация торговой стратегии для Grid-бота"""
        # Проверяем исполнение ордеров
        await self.check_all_orders()
        
        # Создаем/обновляем сетки для активов
        for symbol in self.symbols:
            await self.create_reverse_grid(symbol)
    # - /Метод execute_strategy для Grid-бота -

    # v2.0: Переопределение метода graceful shutdown
    async def _shutdown(self):
        """
        v2.0: Переопределение graceful shutdown для закрытия позиций.
        """
        self.logger.info("🛑 Начало graceful shutdown Grid-бота...")
        await self.close_all_positions()
        # Остановка IPC сервера
        if self.ipc_server:
            await self.ipc_server.stop()
        self.running = False
        self.logger.info("🛑 Graceful shutdown Grid-бота завершен.")

    async def run(self):
        """Основной цикл работы бота"""
        try:
            await self.ex.load_markets()
            await self.update_capital()
            
            # Инициализация капитала
            self.working_capital = self.total_capital * 0.5
            self.reserve_capital = self.total_capital * 0.5
            self.logger.info(f"💰 Инициализация капитала: Всего=${self.total_capital:.2f}, Рабочий=${self.working_capital:.2f}, Резерв=${self.reserve_capital:.2f}")
            
            # v2.0: Переопределение метода распределения капитала
            await self.distribute_capital()
            
            # - ИСПРАВЛЕНИЕ 1: Запуск цикла ежедневного отчета -
            # asyncio.create_task(self._daily_report_loop())
            # - /ИСПРАВЛЕНИЕ 1 -
            
            self.logger.info(f"🟢 Grid Bot запущен. Начальный капитал: {self.total_capital:.2f} USDT")
            await self.send(f"🟢 Grid Bot запущен. Капитал: {self.total_capital:.2f} USDT")
            
            # - ДОБАВЛЕНИЕ 7: Отправка уведомления о старте -
            await self._send_start_notification()
            # - /ДОБАВЛЕНИЕ 7 -
            
            # Основной цикл
            while self.running:
                try:
                    await self.update_capital()
                    
                    # Периодическое перераспределение капитала
                    current_time = time.time()
                    if current_time - self.last_redistribution > self.redistribution_interval:
                        await self.distribute_capital()
                        self.last_redistribution = current_time
                        
                    # - ИСПРАВЛЕНИЕ 2: Снапшот портфеля каждые 5 минут -
                    # if int(time.time()) % 300 == 0:
                    #     await self._log_portfolio_snapshot()
                    # - /ИСПРАВЛЕНИЕ 2 -
                    
                    # Специфичная логика бота
                    await self.execute_strategy()
                    
                    # Пауза
                    sleep_interval = self.config['grid']['sleep_interval']
                    await asyncio.sleep(sleep_interval)
                    
                except ccxt.NetworkError as e:
                    self.logger.error(f"Сетевая ошибка: {e}")
                    await asyncio.sleep(10)
                except ccxt.ExchangeError as e:
                    self.logger.error(f"Биржевая ошибка: {e}")
                    await asyncio.sleep(sleep_interval * 2)
                except Exception as e:
                    self.logger.error(f"❌ Критическая ошибка в основном цикле Grid: {e}")
                    await asyncio.sleep(sleep_interval * 3)
                    
        except Exception as e:
            self.logger.error(f"Критическая ошибка: {e}")
        finally:
            await self._shutdown()

    def exit_gracefully(self, signum, frame):
        """Обработчик сигналов для graceful shutdown"""
        self.logger.info(f"🛑 Grid graceful shutdown (сигнал {signum})")
        self.running = False

    # v2.0: Переопределение метода распределения капитала
    async def distribute_capital(self):
        """
        Переопределяем метод из базового класса для Grid-бота.
        v2.0: Использует CapitalDistributor для корректного распределения.
        """
        self.logger.info("🔄 Начало перераспределения капитала для Grid...")
        
        # v2.0: Используем новый модуль распределения капитала
        distributor = CapitalDistributor(self.ex)
        allocations = await distributor.distribute_for_strategy('grid', self.symbols)
        
        self.allocated_capital = allocations
        
        # Логирование распределения
        for symbol, amount in self.allocated_capital.items():
            self.logger.info(f"💰 {symbol}: выделено ${amount:.2f} USDT")
            
        self.logger.info("✅ Перераспределение капитала для Grid завершено.")

# - Точка входа -
async def main():
    bot = MultiAssetGridBot()
    
    # Запуск IPC сервера
    if bot.ipc_server:
        await bot.ipc_server.start()
        
    await bot.run()

if __name__ == "__main__":
    if not os.path.exists('.env'):
        print("❌ Файл .env не найден!")
        print("Создайте файл .env с вашими API ключами")
        sys.exit(1)
        
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("🛑 Бот остановлен пользователем")
    except Exception as e:
        print(f"❌ Критическая ошибка: {e}")
        logging.error(f"Критическая ошибка: {e}")
# - /Точка входа -

